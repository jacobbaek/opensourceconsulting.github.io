<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>오픈소스컨설팅 
기술 블로그
</title>
    <description>기술을 나눕니다. 함께 성장합니다.
Sharing Tech. Growing Together.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/rss" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 01 Jul 2019 16:23:38 +0900</pubDate>
    <lastBuildDate>Mon, 01 Jul 2019 16:23:38 +0900</lastBuildDate>
    <generator>Jekyll v3.7.4</generator>
    
      <item>
        <title>Openshift Origin v3.11 설치, App 배포</title>
        <description>&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;center&gt;
  &lt;img src=&quot;/assets/images/78611423/0.png&quot; style=&quot;max-width: 100%; height: auto;&quot;/&gt;
 &lt;/center&gt;
 &lt;p&gt;
  안녕하세요 오픈소스컨설팅 한철희 입니다.
  &lt;br/&gt;
  이번 포스팅에서는 Kubernetes에 기반을 둔 Developer-Oriented PaaS 인 Red Hat Openshift를 살펴볼 것입니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#openshift-란&quot; id=&quot;openshift-란&quot;&gt;
   Openshift 란?
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  OpenShift 는 개발자 및 IT 운영팀을 단일 플랫폼에서 통합하여, 하이브리드 클라우드 및 멀티 클라우드 인프라 전반에서 애플리케이션을 일관되게 구축, 배포 및 관리하도록 지원하는 플랫폼입니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#openshift-이점&quot; id=&quot;openshift-이점&quot;&gt;
   Openshift 이점
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#주요-이점&quot; id=&quot;주요-이점&quot;&gt;
   주요 이점
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;ul&gt;
  &lt;li&gt;
   애플리케이션 라이프사이클 전반에 걸쳐 운영 및 개발팀에서 더 큰 가치 실현
  &lt;/li&gt;
  &lt;li&gt;
   애플리케이션 개발 주기 단축 및 소프트웨어 배포 빈도 증가
  &lt;/li&gt;
  &lt;li&gt;
   하이브리드 클라우드 및 멀티 클라우드 전반에서 IT 운영 비용 절감 및 애플리케이션 이식성 실현
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#개발팀을-위한-이점&quot; id=&quot;개발팀을-위한-이점&quot;&gt;
   개발팀을 위한 이점
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;blockquote&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Openshift는 개발자에게 셀프 서비스 방식으로 애플리케이션과 컴포넌트를 프로비저닝, 빌드 및 배포하도록 지원하는 최적의 플랫폼입니다.
   &lt;/li&gt;
   &lt;li&gt;
    Source To Image(S2I) 프로세스 같은 자동화된 워크플로우 덕분에 소스 형상 관리의 소스 코드를 즉시 실행 가능한 도커 포맷 컨테이너 이미지로 간단하게 생성할 수 있습니다.
   &lt;/li&gt;
   &lt;li&gt;
    Openshift는 CI(Continuous Integration)와 CD(Continuous Delivery)의 통합 툴을 제공하기 때문에 모든 조직에게 이상적인 솔루션이 될 수 있습니다.
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/blockquote&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#운영팀을-위한-이점&quot; id=&quot;운영팀을-위한-이점&quot;&gt;
   운영팀을 위한 이점
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;blockquote&gt;
  &lt;ul&gt;
   &lt;li&gt;
    Openshift는 IT 운영팀에 애플리케이션 빌드 배포 자동화와 정책 기반 권한 관리를 지원하는 안전한 엔터프라이즈급 Kubernetes를 제공합니다.
   &lt;/li&gt;
   &lt;li&gt;
    클러스터 서비스, 스케줄링 그리고 오케스트레이션을 통해 부하 분산과 자동 스케일링 기능을 제공합니다. 보안 기능을 통해 테넌트가 다른 애플리케이션이나 기본 호스트에 지장을 주지 않도록 방지합니다.
   &lt;/li&gt;
   &lt;li&gt;
    Openshift는 Persistent Storage를 Linux 컨테이너에 직접 연결할 수 있기 때문에 IT 조직은 하나의 플랫폼에서 스테이트풀(Stateful) 및 스테이트리스(Stateless) 애플리케이션을 모두 실행할 수 있습니다.
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/blockquote&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#openshift-종류&quot; id=&quot;openshift-종류&quot;&gt;
   Openshift 종류
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Openshift 에는 다양한 버전이 존재합니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;strong&gt;
    OpenShift Origin
   &lt;/strong&gt;
   &lt;ul&gt;
    &lt;li&gt;
     OpenShift Online, OpenShift Dedicated 및 OpenShift Container Platform에서 사용되는 업스트림 커뮤니티 프로젝트입니다.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;strong&gt;
    OpenShift Container Platform
   &lt;/strong&gt;
   &lt;ul&gt;
    &lt;li&gt;
     OpenShift Container Platform은 Red Hat이 제공하고 지원하는 엔터프라이즈 버전입니다.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;strong&gt;
    OpenShift Online
   &lt;/strong&gt;
   &lt;ul&gt;
    &lt;li&gt;
     OpenShift Online은 Red Hat의 호스팅형 퍼블릭 PaaS 로서 클라우드에서 애플리케이션 개발, 구축, 배포, 호스팅 솔루션을 제공합니다.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;strong&gt;
    OpenShift Dedicated
   &lt;/strong&gt;
   &lt;ul&gt;
    &lt;li&gt;
     OpenShift Dedicated는 퍼블릭 클라우드에서 관리형 싱글 테넌트 OpenShift 환경을 제공합니다. 전체 OpenShift Cluster를 기업 전용 솔루션으로 구축하고 Red Hat을 통해 종합적으로 관리합니다.
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#openshift-origin-설치&quot; id=&quot;openshift-origin-설치&quot;&gt;
   Openshift Origin 설치
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Openshift 설치 테스트 환경은 아래와 같습니다.
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   CentOS Linux release 7.6.1810 (Core)
   &lt;br/&gt;
   Openshift Origin v3.11
   &lt;br/&gt;
   Docker v1.13.1
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  Openshift 를 설치하기 위해서는 기본적으로 필요한 OS 설정 및 Infra 구성이 필요합니다.
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;p&gt;
    &lt;strong&gt;
     OS 설정
    &lt;/strong&gt;
   &lt;/p&gt;
   &lt;ol&gt;
    &lt;li&gt;
     SELinux : Enforcing
    &lt;/li&gt;
    &lt;li&gt;
     Firewalld Disable / iptables Enable (설치간 자동으로 설정 진행됨)
    &lt;/li&gt;
    &lt;li&gt;
     NetworkManager Enable
    &lt;/li&gt;
   &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;p&gt;
    &lt;strong&gt;
     추가 필요 Infra 요소
    &lt;/strong&gt;
   &lt;/p&gt;
   &lt;ol&gt;
    &lt;li&gt;
     Internal DNS 서버 (이번 포스팅에서는 DNS 시스템 구성 내용은 제외되어 있습니다.)
    &lt;/li&gt;
   &lt;/ol&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  위와 같이 Openshift 를 배포하기 위해서는 기본 설정이 필요합니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#주요-os-설정-부분&quot; id=&quot;주요-os-설정-부분&quot;&gt;
   주요 OS 설정 부분
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  &lt;code&gt;
   /etc/sysconfig/network-script/
  &lt;/code&gt;
  의 내용은 아래와 같은 내부 Internal DNS 및 Upstream DNS 설정 해야됩니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# cat /etc/sysconfig/network-scripts/ifcfg-eth1
TYPE=Ethernet
BOOTPROTO=static
DEFROUTE=yes
NAME=eth1
UUID=XXXXXXXX-XXXXX-XXXX-XXXX-XXXXXXXXXXXXX
DEVICE=eth1
ONBOOT=yes
IPADDR=192.168.XX.50
NETMASK=255.255.255.0
GATEWAY=192.168.XX.XX
DNS1=192.168.XX.111      # Internal DNS
DNS2=1.1.1.1             # Upstream
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   SELinux
  &lt;/code&gt;
  설정 확인
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# cat /etc/selinux/config
...
SELINUX=enforcing         # Enforcing 설정
...
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#dns-설정-부분&quot; id=&quot;dns-설정-부분&quot;&gt;
   DNS 설정 부분
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Internal DNS 는 아래와 같이
  &lt;code&gt;
   Zone File
  &lt;/code&gt;
  을 설정합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# cat /var/named/example.com.zone
$TTL 3H
@	IN SOA	ns.example.com. root.example.com. (
					0	; serial
					1D	; refresh
					1H	; retry
					1W	; expire
					3H )	; minimum

	IN      NS      ns.example.com.
ns	IN	A	192.168.XX.111
*	IN	A	192.168.XX.50             # wildcard DNS 설정
master	IN	A	192.168.XX.50
;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;em&gt;
   &lt;strong&gt;
    wildcard DNS
   &lt;/strong&gt;
  &lt;/em&gt;
  설정을 합니다.
  &lt;br/&gt;
  &lt;strong&gt;
   참고자료 :
  &lt;/strong&gt;
  &lt;a href=&quot;https://docs.openshift.com/container-platform/3.11/install/prerequisites.html#wildcard-dns-prereq&quot;&gt;
   https://docs.openshift.com/container-platform/3.11/install/prerequisites.html#wildcard-dns-prereq
  &lt;/a&gt;
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#requirements-package-설치&quot; id=&quot;requirements-package-설치&quot;&gt;
   Requirements Package 설치
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Openshift 설치를 하기 위해서
  &lt;code&gt;
   centos-openshift-origin311
  &lt;/code&gt;
  Repository 를
  &lt;code&gt;
   Enable
  &lt;/code&gt;
  해야됩니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# yum install centos-release-openshift-origin311.noarch
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: ftp.nara.wide.ad.jp
 * extras: data.aonenetworks.kr
 * updates: ftp.nara.wide.ad.jp
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package centos-release-openshift-origin311.noarch 0:1-2.el7.centos will be installed
--&amp;gt; Processing Dependency: centos-release-paas-common for package: centos-release-openshift-origin311-1-2.el7.centos.noarch
--&amp;gt; Processing Dependency: centos-release-ansible26 for package: centos-release-openshift-origin311-1-2.el7.centos.noarch
--&amp;gt; Running transaction check
---&amp;gt; Package centos-release-ansible26.noarch 0:1-3.el7.centos will be installed
--&amp;gt; Processing Dependency: centos-release-configmanagement for package: centos-release-ansible26-1-3.el7.centos.noarch
---&amp;gt; Package centos-release-paas-common.noarch 0:1-1.el7.centos will be installed
--&amp;gt; Running transaction check
---&amp;gt; Package centos-release-configmanagement.noarch 0:1-1.el7.centos will be installed
--&amp;gt; Finished Dependency Resolution
 
Dependencies Resolved
 
===================================================================================================================================================================================================================================================================================================
 Package                                                                                   Arch                                                          Version                                                               Repository                                                     Size
===================================================================================================================================================================================================================================================================================================
Installing:
 centos-release-openshift-origin311                                                        noarch                                                        1-2.el7.centos                                                        extras                                                         11 k
Installing for dependencies:
 centos-release-ansible26                                                                  noarch                                                        1-3.el7.centos                                                        extras                                                        4.1 k
 centos-release-configmanagement                                                           noarch                                                        1-1.el7.centos                                                        extras                                                        4.3 k
 centos-release-paas-common                                                                noarch                                                        1-1.el7.centos                                                        extras                                                         11 k
 
Transaction Summary
===================================================================================================================================================================================================================================================================================================
Install  1 Package (+3 Dependent packages)
 
Total download size: 31 k
Installed size: 39 k
Is this ok [y/d/N]:y
 
...
Running transaction
  Installing : centos-release-configmanagement-1-1.el7.centos.noarch                                                                                                                                                                                                                           1/4
  Installing : centos-release-ansible26-1-3.el7.centos.noarch                                                                                                                                                                                                                                  2/4
  Installing : centos-release-paas-common-1-1.el7.centos.noarch                                                                                                                                                                                                                                3/4
  Installing : centos-release-openshift-origin311-1-2.el7.centos.noarch                                                                                                                                                                                                                        4/4
  Verifying  : centos-release-paas-common-1-1.el7.centos.noarch                                                                                                                                                                                                                                1/4
  Verifying  : centos-release-configmanagement-1-1.el7.centos.noarch                                                                                                                                                                                                                           2/4
  Verifying  : centos-release-openshift-origin311-1-2.el7.centos.noarch                                                                                                                                                                                                                        3/4
  Verifying  : centos-release-ansible26-1-3.el7.centos.noarch                                                                                                                                                                                                                                  4/4
 
Installed:
  centos-release-openshift-origin311.noarch 0:1-2.el7.centos
 
Dependency Installed:
  centos-release-ansible26.noarch 0:1-3.el7.centos                                             centos-release-configmanagement.noarch 0:1-1.el7.centos                                             centos-release-paas-common.noarch 0:1-1.el7.centos
 
Complete!
[root@master ~]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위와 같이 설치가 완료가 되면 추가로 Openshift Origin v3.11 설치를 위한 Repogitory 가 Enable 됩니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# yum repolist
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: ftp.nara.wide.ad.jp
 * centos-ansible26: data.aonenetworks.kr
 * extras: data.aonenetworks.kr
 * updates: ftp.nara.wide.ad.jp
centos-ansible26                                                                                                                                                                                                                                                            | 2.9 kB  00:00:00
centos-openshift-origin311                                                                                                                                                                                                                                                  | 2.9 kB  00:00:00
(1/2): centos-ansible26/7/x86_64/primary_db                                                                                                                                                                                                                                 | 6.5 kB  00:00:00
(2/2): centos-openshift-origin311/primary_db                                                                                                                                                                                                                                |  19 kB  00:00:00
repo id                                                                                                                                         repo name                                                                                                                                    status
base/7/x86_64                                                                                                                                   CentOS-7 - Base                                                                                                                              10,019
centos-ansible26/7/x86_64                                                                                                                       CentOS-7 - Ansible26                                                                                                                              8
centos-openshift-origin311                                                                                                                      CentOS OpenShift Origin                                                                                                                          31
extras/7/x86_64                                                                                                                                 CentOS-7 - Extras                                                                                                                               409
updates/7/x86_64                                                                                                                                CentOS-7 - Updates                                                                                                                            1,982
repolist: 12,449
[root@master ~]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Openshift Origin v3.11 은 ansible Version 에 종속성이 있어서 추가로
  &lt;code&gt;
   centos-ansible26
  &lt;/code&gt;
  Repository 가
  &lt;code&gt;
   Enable
  &lt;/code&gt;
  됩니다.
 &lt;/p&gt;
 &lt;p&gt;
  추가로 Openshift ansible Playbook 및 ansible 을 설치합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# yum install openshift-ansible ansible
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  설치가 완료되면 아래와 같이
  &lt;code&gt;
   /usr/share/ansible/openshift-ansible/
  &lt;/code&gt;
  경로에 Playbook 이 생성됩니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# cd /usr/share/ansible/openshift-ansible/
[root@master openshift-ansible]# ls -la
합계 12
drwxr-xr-x.  5 root root   72  6월  5 07:14 .
drwxr-xr-x.  3 root root   31  6월  5 07:14 ..
-rw-r--r--.  1 root root 1303 11월  2  2018 ansible.cfg
drwxr-xr-x.  3 root root   34  6월  5 07:15 inventory
drwxr-xr-x. 38 root root 4096  6월  5 07:14 playbooks
drwxr-xr-x. 93 root root 4096  6월  5 07:14 roles
[root@master openshift-ansible]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#all-in-one-inventory-작성&quot; id=&quot;all-in-one-inventory-작성&quot;&gt;
   All-in-one Inventory 작성
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  노드 하나에 master, infra, compute 의 기능을 전부 설치하는 All-in-one Inventory 를 작성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master openshift-ansible]# cat inventory/hosts.localhost
#bare minimum hostfile
 
[OSEv3:children]
masters
nodes
etcd
 
[OSEv3:vars]
# if your target hosts are Fedora uncomment this
#ansible_python_interpreter=/usr/bin/python3
openshift_deployment_type=origin
openshift_portal_net=172.30.0.0/16
# localhost likely doesn't meet the minimum requirements
openshift_disable_check=disk_availability,memory_availability
 
openshift_node_groups=[{'name': 'node-config-all-in-one', 'labels': ['node-role.kubernetes.io/master=true', 'node-role.kubernetes.io/infra=true', 'node-role.kubernetes.io/compute=true']}]
openshift_release=&quot;3.11&quot;
openshift_master_default_subdomain=apps.example.com
 
# uncomment the following to enable htpasswd authentication; defaults to AllowAllPasswordIdentityProvider
openshift_master_identity_providers=[{'name': 'htpasswd_auth', 'login': 'true', 'challenge': 'true', 'kind': 'HTPasswdPasswordIdentityProvider'}]
 
 
[masters]
localhost ansible_connection=local
 
[etcd]
localhost ansible_connection=local
 
[nodes]
# openshift_node_group_name should refer to a dictionary with matching key of name in list openshift_node_groups.
localhost ansible_connection=local openshift_node_group_name=&quot;node-config-all-in-one&quot;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   openshift_master_identity_providers
  &lt;/code&gt;
  항목을 추가하여 htpasswd 기능을 활성화 하였습니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#prerequisitesyml-배포&quot; id=&quot;prerequisitesyml-배포&quot;&gt;
   prerequisites.yml 배포
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Openshift Cluster 배포하기 전에
  &lt;code&gt;
   prerequisites.yml
  &lt;/code&gt;
  를 실행하여 Cluster 구성간 필요한 설정 작업 및 추가 패키지 설치를 합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# ansible-playbook -i inventory/hosts.localhost playbooks/prerequisites.yml
...

PLAY RECAP ****************************************************************************************************************************************************************************************************************************************************************************************
localhost                  : ok=83   changed=23   unreachable=0    failed=0
 
 
INSTALLER STATUS **********************************************************************************************************************************************************************************************************************************************************************************
Initialization  : Complete (0:00:35)
Tuesday 04 June 2019  10:38:27 +0900 (0:00:00.032)       0:01:35.916 ***********
===============================================================================
Ensure openshift-ansible installer package deps are installed ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 19.40s
container_runtime : Install Docker -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 10.40s
os_firewall : need to pause here, otherwise the iptables service starting can sometimes cause ssh to fail --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 10.13s
os_firewall : Wait 10 seconds after disabling firewalld ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 10.10s
Gathering Facts ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 4.49s
openshift_excluder : Install docker excluder - yum ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 4.01s
os_firewall : Install iptables packages ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3.08s
container_runtime : restart container runtime ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 2.88s
container_runtime : Fixup SELinux permissions for docker ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 1.54s
openshift_repos : refresh cache ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 0.76s
openshift_repos : Ensure libselinux-python is installed ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 0.74s
Gather Cluster facts ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 0.66s
os_firewall : Ensure firewalld service is not enabled -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 0.60s
openshift_repos : Configure origin gpg keys ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 0.60s
os_firewall : Start and enable iptables service -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 0.55s
container_runtime : Get current installed Docker version ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 0.52s
container_runtime : Place additional/blocked/insecure registries in /etc/containers/registries.conf ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 0.50s
openshift_repos : Configure correct origin release repository ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 0.46s
container_runtime : Configure Docker service unit file ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 0.45s
Detecting Operating System from ostree_booted ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 0.44s
[root@master openshift-ansible]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#deploy-clusteryml-배포&quot; id=&quot;deploy-clusteryml-배포&quot;&gt;
   deploy_cluster.yml 배포
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  &lt;code&gt;
   prerequisites.yml
  &lt;/code&gt;
  가 위와 같이 정상적으로 배포가 되면 Cluster 구성 준비가 완료 된 것입니다.
  &lt;br/&gt;
  &lt;code&gt;
   deploy_cluster.yml
  &lt;/code&gt;
  을 이용하여 Cluster 배포를 시작합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# ansible-playbook -i inventory/hosts.localhost playbooks/deploy_cluster.yml
...

PLAY RECAP ****************************************************************************************************************************************************************************************************************************************************************************************
localhost                  : ok=566  changed=138  unreachable=0    failed=0
 
 
INSTALLER STATUS **********************************************************************************************************************************************************************************************************************************************************************************
Initialization               : Complete (0:00:23)
Health Check                 : Complete (0:00:38)
Node Bootstrap Preparation   : Complete (0:01:14)
etcd Install                 : Complete (0:00:32)
Master Install               : Complete (0:04:37)
Master Additional Install    : Complete (0:00:36)
Node Join                    : Complete (0:00:18)
Hosted Install               : Complete (0:00:40)
Cluster Monitoring Operator  : Complete (0:00:11)
Web Console Install          : Complete (0:00:40)
Console Install              : Complete (0:00:18)
metrics-server Install       : Complete (0:00:01)
Service Catalog Install      : Complete (0:03:39)
Tuesday 04 June 2019  11:23:04 +0900 (0:00:00.096)       0:14:35.316 **********
===============================================================================
openshift_control_plane : Wait for all control plane pods to become ready ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 97.17s
/root/openshift-ansible/roles/openshift_control_plane/tasks/main.yml:272 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
template_service_broker : Verify that TSB is running -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 53.92s
/root/openshift-ansible/roles/template_service_broker/tasks/deploy.yml:52 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_service_catalog : Wait for Controller Manager rollout success ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 43.92s
/root/openshift-ansible/roles/openshift_service_catalog/tasks/start.yml:14 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_control_plane : Wait for control plane pods to appear --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 42.90s
/root/openshift-ansible/roles/openshift_control_plane/tasks/main.yml:220 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Run health checks (install) - EL ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 37.39s
/root/openshift-ansible/playbooks/openshift-checks/private/install.yml:24 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_service_catalog : Wait for API Server rollout success --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 32.19s
/root/openshift-ansible/roles/openshift_service_catalog/tasks/start.yml:2 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_web_console : Pause for the web console deployment to start --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 30.16s
/root/openshift-ansible/roles/openshift_web_console/tasks/install.yml:158 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_service_catalog : oc_process ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 16.35s
/root/openshift-ansible/roles/openshift_service_catalog/tasks/install.yml:44 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_console : Waiting for console rollout to complete -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 9.06s
/root/openshift-ansible/roles/openshift_console/tasks/start.yml:2 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_manageiq : Configure role/user permissions --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 5.73s
/root/openshift-ansible/roles/openshift_manageiq/tasks/main.yaml:45 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
tuned : Restart tuned service -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 5.41s
/root/openshift-ansible/roles/tuned/tasks/main.yml:38 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_control_plane : Wait for APIs to become available -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 5.29s
/root/openshift-ansible/roles/openshift_control_plane/tasks/check_master_api_is_ready.yml:2 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_node : Install node, clients, and conntrack packages ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 4.55s
/root/openshift-ansible/roles/openshift_node/tasks/install.yml:2 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
tuned : Restart tuned service -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 4.05s
/root/openshift-ansible/roles/tuned/tasks/main.yml:38 --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Gathering Facts ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3.86s
/root/openshift-ansible/playbooks/init/basic_facts.yml:2 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_excluder : Install docker excluder - yum ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3.62s
/root/openshift-ansible/roles/openshift_excluder/tasks/install.yml:9 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_cli : Install clients ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 3.57s
/root/openshift-ansible/roles/openshift_cli/tasks/main.yml:2 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ansible_service_broker : Create custom resource definitions for asb ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ 3.29s
/root/openshift-ansible/roles/ansible_service_broker/tasks/install.yml:128 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_hosted : Create OpenShift router ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3.22s
/root/openshift-ansible/roles/openshift_hosted/tasks/router.yml:85 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
openshift_control_plane : Start and enable self-hosting node ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 3.04s
/root/openshift-ansible/roles/openshift_control_plane/tasks/main.yml:201 -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
[root@master openshift-ansible]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  배포가 완료되면 아래와 같이
  &lt;code&gt;
   # oc get all
  &lt;/code&gt;
  명령을 통해 Openshift 가 정상적으로 설치가 된 것을 확인 할 수 있습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# oc get all
NAME                           READY     STATUS    RESTARTS   AGE
pod/docker-registry-1-9t2zp    1/1       Running   0          10m
pod/registry-console-1-n4v9t   1/1       Running   0          10m
pod/router-1-58cpz             1/1       Running   3          10m

NAME                                       DESIRED   CURRENT   READY     AGE
replicationcontroller/docker-registry-1    1         1         1         10m
replicationcontroller/registry-console-1   1         1         1         10m
replicationcontroller/router-1             1         1         1         10m

NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                   AGE
service/docker-registry    ClusterIP   172.30.205.4     &amp;lt;none&amp;gt;        5000/TCP                  10m
service/kubernetes         ClusterIP   172.30.0.1       &amp;lt;none&amp;gt;        443/TCP,53/UDP,53/TCP     10m
service/registry-console   ClusterIP   172.30.204.108   &amp;lt;none&amp;gt;        9000/TCP                  10m
service/router             ClusterIP   172.30.237.203   &amp;lt;none&amp;gt;        80/TCP,443/TCP,1936/TCP   10m

NAME                                                  REVISION   DESIRED   CURRENT   TRIGGERED BY
deploymentconfig.apps.openshift.io/docker-registry    1          1         1         config
deploymentconfig.apps.openshift.io/registry-console   1          1         1         config
deploymentconfig.apps.openshift.io/router             1          1         1         config

NAME                                        HOST/PORT                                   PATH      SERVICES           PORT      TERMINATION   WILDCARD
route.route.openshift.io/docker-registry    docker-registry-default.apps.example.com              docker-registry    &amp;lt;all&amp;gt;     passthrough   None
route.route.openshift.io/registry-console   registry-console-default.apps.example.com             registry-console   &amp;lt;all&amp;gt;     passthrough   None
[root@master ~]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#htpasswd-설정--user-권한-설정&quot; id=&quot;htpasswd-설정--user-권한-설정&quot;&gt;
   Htpasswd 설정 &amp;amp;&amp;amp; USER 권한 설정
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  htpasswd 설정을 동해 Openshift Cluster를 관리할
  &lt;code&gt;
   admin
  &lt;/code&gt;
  계정을 생성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# cat /etc/origin/master/master-config.yaml | grep htpasswd
    name: htpasswd_auth
      file: /etc/origin/master/htpasswd
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Master 설정을 확인하여 htpasswd 가 저장되는 경로를 확인합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master master]# htpasswd /etc/origin/master/htpasswd admin
New password:
Re-type new password:
Updating password for user admin

[root@master master]# cat /etc/origin/master/htpasswd
admin:$apr1$vfGx9xr2$G9/SgRxXUupu/mUVSuwmR/
[root@master master]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;code&gt;
   htpasswd
  &lt;/code&gt;
  명령을 이용하여 신규 사용자
  &lt;code&gt;
   admin
  &lt;/code&gt;
  을 생성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master master]# oc login -u admin
Authentication required for https://master.example.com:8443 (openshift)
Username: admin
Password:
Login successful.

You have access to the following projects and can switch between them with 'oc project &amp;lt;projectname&amp;gt;':
...
  * sample-project
...
Using project &quot;&quot;.
[root@master master]# oc new-project sample-project
Now using project &quot;sample-project&quot; on server &quot;https://master.example.com:8443&quot;.

You can add applications to this project with the 'new-app' command. For example, try:

    oc new-app centos/ruby-25-centos7~https://github.com/sclorg/ruby-ex.git

to build a new example application in Ruby.
[root@master master]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  신규로 생성된
  &lt;code&gt;
   admin
  &lt;/code&gt;
  으로 login을 하고 사용할 Project 를 생성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master master]# oc login -u system:admin
Logged into &quot;https://master.example.com:8443&quot; as &quot;system:admin&quot; using existing credentials.

You have access to the following projects and can switch between them with 'oc project &amp;lt;projectname&amp;gt;':
...
  * sample-project
...
Using project &quot;sample-project&quot;.

[root@master master]# oc adm policy add-scc-to-user anyuid -z default
scc &quot;anyuid&quot; added to: [&quot;system:serviceaccount:sample-project:default&quot;]

[root@master master]# oc login -u admin
Logged into &quot;https://master.example.com:8443&quot; as &quot;admin&quot; using existing credentials.

You have access to the following projects and can switch between them with 'oc project &amp;lt;projectname&amp;gt;':
...
  * sample-project
...
Using project &quot;sample-project&quot;.
[root@master master]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  default serviceaccount 에 anyuid scc 를 추가하여 pod 를 제어 할 수 있는 권한을 부여합니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#sample-app-배포&quot; id=&quot;sample-app-배포&quot;&gt;
   Sample APP 배포
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Sample APP 를 배포하여 실제로 Openshift 를 이용하여 서비스를 시작해보겠습니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#s2i-기능을-이용한-app-배포&quot; id=&quot;s2i-기능을-이용한-app-배포&quot;&gt;
   S2I 기능을 이용한 APP 배포
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Openshift 의 S2I 기능을 이용하여 Sample APP 를 배포하겠습니다.
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   APP : wildfly:latest
   &lt;br/&gt;
   Source :
   &lt;a href=&quot;https://github.com/chhanz/openshift-deploy.git&quot;&gt;
    https://github.com/chhanz/openshift-deploy.git
   &lt;/a&gt;
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# oc new-app wildfly~https://github.com/chhanz/openshift-deploy --name sampleapp
--&amp;gt; Found image 05e5cf6 (2 weeks old) in image stream &quot;openshift/wildfly&quot; under tag &quot;13.0&quot; for &quot;wildfly&quot;

    WildFly 13.0.0.Final
    --------------------
    Platform for building and running JEE applications on WildFly 13.0.0.Final

    Tags: builder, wildfly, wildfly13

    * A source build using source code from https://github.com/chhanz/openshift-deploy will be created
      * The resulting image will be pushed to image stream tag &quot;sampleapp:latest&quot;
      * Use 'start-build' to trigger a new build
    * This image will be deployed in deployment config &quot;sampleapp&quot;
    * Port 8080/tcp will be load balanced by service &quot;sampleapp&quot;
      * Other containers can access this service through the hostname &quot;sampleapp&quot;

--&amp;gt; Creating resources ...
    imagestream.image.openshift.io &quot;sampleapp&quot; created
    buildconfig.build.openshift.io &quot;sampleapp&quot; created
    deploymentconfig.apps.openshift.io &quot;sampleapp&quot; created
    service &quot;sampleapp&quot; created
--&amp;gt; Success
    Build scheduled, use 'oc logs -f bc/sampleapp' to track its progress.
    Application is not exposed. You can expose services to the outside world by executing one or more of the commands below:
     'oc expose svc/sampleapp'
    Run 'oc status' to view your app.
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  신규 APP 가 생성이 되고 sample.war 소스를 기반으로
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# oc logs -f bc/sampleapp
Cloning &quot;https://github.com/chhanz/openshift-deploy&quot; ...
	Commit:	7c4656f9d88fe9ffbf846ba0dff5b74742f34c67 (Change Location)
	Author:	chhanz &amp;lt;han0495@gmail.com&amp;gt;
	Date:	Fri Jun 7 22:00:34 2019 +0900
Using docker-registry.default.svc:5000/openshift/wildfly@sha256:895e0a6c732f8244ce75b376651155fdef12311df0d940ce111756ef43aa2bfc as the s2i builder image
Moving binaries in source directory into /wildfly/standalone/deployments for later deployment...
Moving all war artifacts from /opt/app-root/src/. directory into /wildfly/standalone/deployments for later deployment...
'/opt/app-root/src/./sample.war' -&amp;gt; '/wildfly/standalone/deployments/sample.war'
Moving all ear artifacts from /opt/app-root/src/. directory into /wildfly/standalone/deployments for later deployment...
Moving all rar artifacts from /opt/app-root/src/. directory into /wildfly/standalone/deployments for later deployment...
Moving all jar artifacts from /opt/app-root/src/. directory into /wildfly/standalone/deployments for later deployment...
...done

Pushing image docker-registry.default.svc:5000/sample-project/sampleapp:latest ...
Pushed 2/13 layers, 15% complete
Pushed 3/13 layers, 23% complete
Pushed 4/13 layers, 31% complete
Pushed 5/13 layers, 39% complete
Pushed 6/13 layers, 46% complete
Pushed 7/13 layers, 54% complete
Pushed 8/13 layers, 62% complete
Pushed 9/13 layers, 69% complete
Pushed 10/13 layers, 77% complete
Pushed 11/13 layers, 85% complete
Pushed 12/13 layers, 92% complete
Pushed 13/13 layers, 100% complete
Push successful
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위와 같이 git 에서 소스를 가져와서 이미지로 생성하고 Openshift registory 에 Push 합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# oc get po
NAME                READY     STATUS      RESTARTS   AGE
sampleapp-1-build   0/1       Completed   0          4m
sampleapp-1-rsklv   1/1       Running     0          3m
[root@master ~]#

[root@master ~]# oc get svc
NAME        TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE
sampleapp   ClusterIP   172.30.37.118   &amp;lt;none&amp;gt;        8080/TCP   4m
[root@master ~]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  생성된 service 를 이용하여 route 를 생성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@master ~]# oc expose service/sampleapp
route.route.openshift.io/sampleapp exposed
[root@master ~]# oc get route
NAME        HOST/PORT                                   PATH      SERVICES    PORT       TERMINATION   WILDCARD
sampleapp   sampleapp-sample-project.apps.example.com             sampleapp   8080-tcp                 None
[root@master ~]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  sampleapp 에 대한 route 가 생성이 되었습니다.
  &lt;br/&gt;
  실제로 서비스가 되는지 확인하도록 하겠습니다.
 &lt;/p&gt;
 &lt;center&gt;
  &lt;img src=&quot;/assets/images/78611423/1.png&quot; style=&quot;max-width: 100%; height: auto;&quot;/&gt;
  &lt;br/&gt;
  sample 서비스 정상 구동중
 &lt;/center&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#web-console&quot; id=&quot;web-console&quot;&gt;
   Web Console
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Openshift 는 Web Console 을 제공하여 좀더 편리하게 서비스를 배포하고 운영 할 수 있도록 하고 있습니다.
 &lt;/p&gt;
 &lt;center&gt;
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/78611423/2.png&quot;  style=&quot;max-width: 100%; height: auto;&quot;/&gt;
  &lt;br/&gt;
  Openshift Web Condole
  &lt;br/&gt;
 &lt;/center&gt;
 admin 계정으로 로그인을 하겠습니다.
 &lt;center&gt;
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/78611423/3.png&quot;  style=&quot;max-width: 100%; height: auto;&quot;/&gt;
  &lt;br/&gt;
  배포된 sampleapp 어플리케이션
  &lt;br/&gt;
 &lt;/center&gt;
 위와 같이 배포된 어플리케이션들에 대해 상태를 확인하고 Scale Up/Down 등의 기능을 수행이 가능합니다.
 &lt;center&gt;
  &lt;br/&gt;
  &lt;img src=&quot;/assets/images/78611423/4.png&quot; style=&quot;max-width: 100%; height: auto;&quot;/&gt;
  &lt;br/&gt;
  Openshift Grafana
  &lt;br/&gt;
 &lt;/center&gt;
 &lt;p&gt;
  Openshift Origin v3.11에는 기본적으로 Prometheus + Grafana Dashboard 를 제공하고 있습니다.
  &lt;br/&gt;
  &lt;em&gt;
   &lt;strong&gt;
    (openshift-monitoring Project 에서 실행중)
   &lt;/strong&gt;
  &lt;/em&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이번 포스팅에서는 Openshift Origin 설치 및 APP 를 배포하여 서비스가 동작되는 것을 확인 하였습니다.
  &lt;br/&gt;
  이후 포스팅에서는 Web Console 를 통한 배포/관리, HPA 를 이용한 Auto-Scaling 구현을 작성해보도록 하겠습니다.
 &lt;/p&gt;
 &lt;p&gt;
  감사합니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#참고자료&quot; id=&quot;참고자료&quot;&gt;
   참고자료
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;ul&gt;
  &lt;li&gt;
   설치 관련 참고 자료
   &lt;ul&gt;
    &lt;li&gt;
     DNS 구성 관련 :
     &lt;a href=&quot;https://www.unixmen.com/setting-dns-server-centos-7/&quot;&gt;
      https://www.unixmen.com/setting-dns-server-centos-7/
     &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
     DNS 설정 관련 :
     &lt;a href=&quot;https://docs.openshift.com/container-platform/3.11/install/prerequisites.html#wildcard-dns-prereq&quot;&gt;
      https://docs.openshift.com/container-platform/3.11/install/prerequisites.html#wildcard-dns-prereq
     &lt;/a&gt;
    &lt;/li&gt;
    &lt;li&gt;
     ansible-playbook inventory 관련 :
     &lt;a href=&quot;https://docs.okd.io/3.11/install/configuring_inventory_file.html&quot;&gt;
      https://docs.okd.io/3.11/install/configuring_inventory_file.html
     &lt;/a&gt;
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
   scc 관련
   &lt;ul&gt;
    &lt;li&gt;
     &lt;a href=&quot;https://blog.openshift.com/understanding-service-accounts-sccs/&quot;&gt;
      https://blog.openshift.com/understanding-service-accounts-sccs/
     &lt;/a&gt;
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
   git source
   &lt;ul&gt;
    &lt;li&gt;
     chhanz github :
     &lt;a href=&quot;https://github.com/chhanz/openshift-deploy&quot;&gt;
      https://github.com/chhanz/openshift-deploy
     &lt;/a&gt;
    &lt;/li&gt;
   &lt;/ul&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 10 Jun 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/06/10/78611423/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/06/10/78611423/</guid>
        
        
      </item>
    
      <item>
        <title>Open Infrastructure Summit 2019 후기</title>
        <description>&lt;p&gt;
 안녕하십니까. 오픈소스컨설팅입니다.
&lt;/p&gt;
&lt;p&gt;
 지난 4월 29일 ~ 5월 1일, 미국 덴버의 Colorado Convention Center에서 Open Infrastructure Summit 2019 행사가 개최되었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;iframe allowfullscreen=&quot;&quot; class=&quot;youtube-player conf-macro output-block&quot; data-hasbody=&quot;false&quot; data-macro-name=&quot;widget&quot; frameborder=&quot;0&quot; mozallowfullscreen=&quot;&quot; src=&quot;//www.youtube.com/embed/Pzqqi8wIBT8?wmode=opaque&quot; style=&quot;width: 340px; height: 300px&quot; type=&quot;text/html&quot; webkitallowfullscreen=&quot;&quot;&gt;
 &lt;/iframe&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 기존의 OpenStack Summit에서 Open Infrastructure Summit으로 이름을 바꾸고 처음 열린 이번 행사에서는
 &lt;span class=&quot;s1&quot;&gt;
  Container Infrastructure, CI/CD, Telecom + NFV, Public Cloud, Private &amp;amp; Hybrid Cloud, Security와 관련된 300여개의 세션과 워크샵이 열렸습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 본 포스팅에서는 이번 Summit에 참석하면서 듣고 느낀 내용을 공유하려고 합니다.
&lt;/p&gt;
&lt;h1 id=&quot;OpenInfrastructureSummit2019후기-Summit이남긴메시지1-경계없는협업(Collaborationwithoutborder)&quot;&gt;
 Summit이 남긴 메시지 1 -
 &lt;span style=&quot;color: rgb(0,0,0);&quot;&gt;
  &lt;strong&gt;
   경계 없는 협업 (Collaboration without border)
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/h1&gt;
&lt;p&gt;
 &lt;span class=&quot;s1&quot;&gt;
  OpenStack Foundation의 Executive Director이자 Rackspace의 창업자인 Jonathan Bryce는 키노트 세션을 통해 열린 협업(Open Collaboration), 경계 없는 협업(Collaboration without border)을 강조했습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;s1&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140128/0.jpeg&quot;/&gt;
  &lt;/span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140128/1.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;s1&quot;&gt;
  OpenStack이 다른 오픈소스 프로젝트와의 통합과 협업을 통해 Open Infrastructure로서, 다양한 분야에서 직면한 과제를 해결할 수 있음을 강조한 것입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;s1&quot;&gt;
  특히 최근 OpenStack user survey에서 OpenStack 사용자 중 61%가 OpenStack 환경에서 Kubernetes를 사용하고 있다는 조사 결과를 인용하면서, OpenStack 프로젝트와 Kubernetes 프로젝트와의 협업이 계속되고 있다는 것을 강조했습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;s1&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140128/2.svg&quot;/&gt;
  &lt;/span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140128/3.svg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;s1&quot;&gt;
  *출처: 2018 OpenStack User Survey Report (
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.openstack.org/user-survey/2018-user-survey-report/&quot; rel=&quot;nofollow&quot;&gt;
   https://www.openstack.org/user-survey/2018-user-survey-report/
  &lt;/a&gt;
  )
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;s1&quot;&gt;
  이는 OpenStack 커뮤니티가 Kubernetes와의 통합을 매우 중요하게 생각하고 있다는 것과, OpenStack이 VM 뿐만 아니라 컨테이너 운영까지 가능한 플랫폼으로 확산 중임을 의미합니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 이번 Summit에서는 OpenStack Foundation의 첫번째 Pilot Project로 시작된 Kata Containers가 Confirmed Project가 되었음을 알렸습니다.
&lt;/p&gt;
&lt;p&gt;
 Kata Containers는 기존의 컨테이너가 가지고 있던 신속성과 VM이 가지는 보안의 장점을 결합한  Lightweight VM으로서, Docker OCI와 Kubernetes CRI를 지원합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 특히 1.5 버전부터는 AWS에서 serverless 서비스를 위해 개발한 오픈소스 하이퍼바이저인 Firecracker를 지원합니다. Firecracker는 AWS의 Lambda 서비스와 Fargate 서비스에 사용되고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Serverless 기술에 대한 관심과 도입은 증가하고 있습니다. 그리고 보안이 강화된 컨테이너, 또는 Lightweight VM은 serverless의 핵심 기술로 주목받고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/7.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 *출처: Where PaaS, Containers and Serverless Stand in a Multi-Platform World, June 2018, CLOUDFOUNDRY (
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.cloudfoundry.org/wp-content/uploads/GPS-7-FINAL-REPORT-.pdf&quot; rel=&quot;nofollow&quot;&gt;
  https://www.cloudfoundry.org/wp-content/uploads/GPS-7-FINAL-REPORT-.pdf
 &lt;/a&gt;
 )
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 OpenStack Foundation의 Kata Containers 프로젝트와 AWS에서 시작된 Firecracker 프로젝트의 협업이 serverless와 컨테이너 기술의 지형을 어떻게 변화시킬지 궁금해집니다.
&lt;/p&gt;
&lt;h1 id=&quot;OpenInfrastructureSummit2019후기-Summit이남긴메시지2-5G,그리고Edge&quot;&gt;
 Summit이 남긴 메시지 2 -
 &lt;span style=&quot;color: rgb(0,0,0);&quot;&gt;
  &lt;strong&gt;
   5G, 그리고 Edge
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/h1&gt;
&lt;p&gt;
 5G와 Edge는 이번 Summit의 처음과 끝을 관통하는 주제였습니다. 키노트 세션에서는 Ericsson과 AT&amp;amp;T에서 OpenStack을 기반으로 한 자사의 5G 구축 사례를 발표했습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/9.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/10.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 뒤이어 Ericsson과 AT&amp;amp;T가 파트너가 되어 가상현실 게임을 시연하면서 참석자들에게 3G, 4G, 5G의 네트워크 지연시간의 차이를 보여주는 행사를 가졌습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140128/11.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 중국 최대 통신회사인 China Mobile은 OpenStack의 NFV 아키텍처를 기반으로 한 5G 시스템과 Edge 컴퓨팅 구축 사례를 발표하는 세션을 가졌습니다.
&lt;/p&gt;
&lt;p&gt;
 이밖에 Intel, EMC, Redhat, Dell, Lenovo 등 많은 업체가 5G와 Edge를 위한 솔루션을 소개하는 세션을 가졌습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 OpenStack이 5G의 데이터 허브(hub) 역할을 하는 Edge 클라우드 기반 인프라로 자리 잡았음을 느낄 수 있었던 행사였습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Fri, 31 May 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/05/31/77140128/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/31/77140128/</guid>
        
        
      </item>
    
      <item>
        <title>오픈소스컨설팅 마케팅팀의 심오한 워크샵 셀프후기</title>
        <description>&lt;h2 id=&quot;id-오픈소스컨설팅마케팅팀의심오한워크샵셀프후기-#feat.자유롭게써보는오픈소스컨설팅마케팅팀이일하는방법.&quot;&gt;
 &lt;span style=&quot;color: rgb(0,0,128);&quot;&gt;
  &lt;strong&gt;
   #
  &lt;/strong&gt;
  &lt;strong&gt;
   feat.자유롭게 써보는 오픈소스컨설팅 마케팅팀이 일하는 방법.
  &lt;/strong&gt;
 &lt;/span&gt;
&lt;/h2&gt;
&lt;p&gt;
 안녕하세요. 저는 오픈소스컨설팅 마케팅팀 디자이너, 로즈영입니다.
 &lt;br/&gt;
 처음으로 저희 블로그에 게재해 보는 글이라서 설레임반 긴장반 인데요, 그래도 한번 끄적해보겠습니다~ㅎ
&lt;/p&gt;
&lt;p&gt;
 사실 저희 블로그에다 글을 써볼 기회는 없었는데, 어찌저찌 에너지 넘치는 저희 팀원들끼리 얘기를 하다가 우리끼리의
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/77140019/0.svg&quot;/&gt;
 &lt;/span&gt;
 미니워크샵을 추진했더랬죠..
 &lt;br/&gt;
 많은 논의 끝에 롯데월드라는 심플한 장소가 선택되었고,  이왕 가는거 블로그에 포스팅하면 재밌을 것 같아 키보드를 끄적하길 시작했습니다!! + _+ (짝짝짝~!!)
&lt;/p&gt;
&lt;p&gt;
 워크샵의 가장 긍정적인 효과는 평소 깊이 나누지 못했던 사적인 얘기까지 하니깐 한껏 더 새롭고 서로에게 가까워진 느낌이 들었습니다.
 &lt;br/&gt;
 평소에 회사에서 워낙 말도 많이 하고 서로 너무 친하다고 생각했는데, 슬랙으로 많이 대화를 해서 새로울 것이 없을거라 생각했는데,
 &lt;br/&gt;
 외부에서 서로 스터디한 걸 세미나로 발표도 하고나니 더욱 새로웠던 것 같습니다.
&lt;/p&gt;
&lt;p&gt;
 (롯데월드 놀이기구를 더운날씨와 많은 인파로 3개 밖에 못탄것이 약간 아쉽  ...)
&lt;/p&gt;
&lt;p&gt;
 저희 오픈소스컨설팅에 입사하면서 가장 저에게 있어서 큰 변화라고 생각하는 것 중 하나는 바로 &amp;lt;저만의 고찰의 시간&amp;gt;입니다.
 &lt;br/&gt;
 저희팀과의 팀웍, 그리고 나의 감정, 또 다른 팀과의 협업에 있어서 많이 돌아보게 되는 여유를 갖게된 것인데, 아무래도 격주 4일제의 긍정효과가 아닌가 싶습니다 ㅎ
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/1.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/2.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/3.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스컨설팅마케팅팀의심오한워크샵셀프후기-#흐뭇한미소가번지는복리후생&quot;&gt;
 &lt;strong&gt;
  # 흐뭇한 미소가 번지는 복리후생
 &lt;/strong&gt;
&lt;/h3&gt;
&lt;p&gt;
 격주 4일제의 근무형태는 좀 더 집중하고 놀때놀고 쉴때 쉬는 그런 집중도 있는 사내문화로 자연스럽게 정착되게끔 만든 것 같습니다.
 &lt;br/&gt;
 워라벨이 높은만큼 퇴근 후 동료들과 간단한 치맥도 하지만, 어학이라던가 새로운 신기술 세미나나 세션, 공부를 하기위해 스터디하는 분들이 많은 것도 그런 문화에서 기인하는 것 같습니다.
&lt;/p&gt;
&lt;p&gt;
 사실 저 개인적으로는 저희 오픈소스컨설팅이 흔히 말하는 신의..꿈의 직장이 되어간다고 생각합니다 :)
 &lt;br/&gt;
 사람을 진정성있게 대하고, 그 사람이 함께 긍정적인 에너지를 뿜을 수 있게 도와주는 다양한 복리후생은 비단 격주 4일제만이 아닌데요~
&lt;/p&gt;
&lt;p&gt;
 년간 360만원의 복리후생비 지원, 매주 월요일은 10시출근, 조식제공, 통신비 지원, 교육지원, 매년 1인동반 해외워크샵 추진, 입사시 웰컴키트 제공, 경조사 축/조의금 및 명절,승진,생일 선물 제공, 부서별 회식비 지원, 미취학아동 육아비 지원 등..
 &lt;br/&gt;
 (뜨헉!! ㅎㅎㅎ) 국내 업체들 중에서는 손꼽히는 복리후생이라고 자부합니다..ㅎ
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/4.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/5.jpeg&quot;/&gt;
  &lt;/span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/6.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 정서적으로는 함께 소통하는 문화가 많은데요., 메신져로 쓰고 있는 슬랙 뿐만아니라, 최근에는 동호회가 많이 신설되면서 더욱 활발한 교류가 지속중에 있습니다.
 &lt;br/&gt;
 일방향적인 목적과 목표가 아닌 스스로 효율적인 방안과 해결방안을 위해서 노력해서 좀 더 능동적인 문화를 만들어간다는 생각이 많이 들었습니다.
 &lt;br/&gt;
 ( Wow!! 정말 다니고 싶은 회사이지 않나요? ㅎㅎㅎ )
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
 저희 회사에 대한 간략소개를 끝 마치고, 오늘은 특별히 저희 오픈소스컨설팅의 꽃이자 핵심 조직(?)인 ㅎㅎ 마케팅팀을 소개하겠습니다~! (짝짝짝~!!)
&lt;/p&gt;
&lt;p&gt;
 저희 팀을 설명하는 키워드는 세가지로 말할 수 있습니다.
 &lt;br/&gt;
 각자의 자립심이 강한 저희 3인방은 센스쟁이 마케터들 2인/ 디자이너 1인으로 구성되어있는 매우 알찬 조직입니다!~: )
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스컨설팅마케팅팀의심오한워크샵셀프후기-01.쇠똥구리열정3인방&quot;&gt;
 01. 쇠똥구리 열정 3인방
&lt;/h3&gt;
&lt;p&gt;
 모두들 쇠똥구리를 닮은 집념과 능동적인 삶을 살고 있습니다!
&lt;/p&gt;
&lt;p&gt;
 우리는 워커홀릭이라고 인정하고 싶지 않지만 업무의 일상 속에서 자연스러운 대화를 하다가도
 &lt;br/&gt;
 의식의 흐름은 직업병스토리로 간다고 해야 할까요?.. 현재 제가 블로그를 쓰고 있는 것도, 자연스럽게 흘러간 직업병 결과의 일환이네여..ㅎ
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/7.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/8.jpeg&quot;/&gt;
  &lt;/span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/9.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 커피를 마시면서 수다를 떨고 있는 어느순간,
 &lt;br/&gt;
 어머!!!! 이 까페는 이런 핑크핑크한 인테리어로 사진찍고 싶은 까페를 컨셉으로 인스타그램 하고 있구나...!
 &lt;br/&gt;
 라고... ㅎㅎㅎ 생각하는 직업병..ㅎ
&lt;/p&gt;
&lt;p&gt;
 식당에서 밥을 먹는데도....
 &lt;br/&gt;
 어머!! 여기는 홍보 X배너 부자재가 너무 특이한데?
 &lt;br/&gt;
 입구에 로고가 골드 스카시로 제작했는데, 너무 이쁘다!!!
 &lt;br/&gt;
 바닥 마블이 꼭 우주 같은데요??...... 라고 생각하는 .. 일과 사적인 경계가 없는(?) 일원화 된 삶.ㅎㅎㅎ
&lt;/p&gt;
&lt;p&gt;
 한편으로는 일복은 넣어두고 싶은데, 라고 생각하지만 ..이내 또 정신차려보면 일하고 있는 제 자신을 발견하게 되서 큰일( ? )입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/77140019/10.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 읽었던 책중에서 이나모리 가즈오의 &amp;lt;왜 일하는가&amp;gt;에서 일을 사랑해야 즐겁다는 말이 나옵니다.
 &lt;br/&gt;
 일에 대한 강한 집념과 애정이 없다면 아무리 좋은 환경에서 일해도 좋은 결과를 얻을 수 없다고 하는데, 저희 마케팅 팀원들을 볼때마다
 &lt;br/&gt;
 일에 대한 애정과 재미있어서 진심으로 즐기는 화이팅 감성이 느껴집니다.
 &lt;br/&gt;
 항상 자극이 되고, 서로 더 시너지를 내는 방향에 대해서 고민할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스컨설팅마케팅팀의심오한워크샵셀프후기-02.말랑말랑마케팅팀🍮&quot;&gt;
 02. 말랑말랑 마케팅팀 🍮
&lt;/h3&gt;
&lt;p&gt;
 저희 마케팅팀은 저희 오픈소스컨설팅처럼 유연합니다. 아니, 말랑말랑합니다.
 &lt;br/&gt;
 커피 타임 스몰 톡부터 회의 중 작은 농담까지, 그 어떤 생각도 결코 외면하거나 무시당하지 않습니다.
&lt;/p&gt;
&lt;p&gt;
 작은 아이디어로부터 시작하는 모든 것이 곧 우리 마케팅팀의 영양분이 되니까요!
 &lt;br/&gt;
 항상 최고의 결과를 내고자 하지만, 그게 여의치 않은 상황도 분명히 있습니다.
&lt;/p&gt;
&lt;p&gt;
 처음의 결정이 좌절될 때도 결코 포기하지 않습니다.
 &lt;br/&gt;
 그럴 때마다 서로의 의견을 공유한 뒤 더 나은 결정으로 나아가고자 합니다.
&lt;/p&gt;
&lt;p&gt;
 마케팅팀은 안팎으로 더 많이 대화하고 서로의 감정을 이해하기 위해 노력합니다.
 &lt;br/&gt;
 오픈소스컨설팅이 지향하는 협업 문화가 바로 그런 것이죠.
&lt;/p&gt;
&lt;p&gt;
 일이 놀이가 되고, 놀이가 곧 일이 되는 문화, 바로 마케팅팀이 이룩하고자 하고 실현해나가고 있는 팀 문화입니다.
&lt;/p&gt;
&lt;h3 id=&quot;id-오픈소스컨설팅마케팅팀의심오한워크샵셀프후기-03.🏄🏼‍♂️파도위의보드같은마케팅팀.&quot;&gt;
 &lt;br/&gt;
 03. 🏄🏼‍♂️ 파도 위의 보드같은 마케팅팀.
&lt;/h3&gt;
&lt;p&gt;
 거친 파도 위에서 보드를 타려면 엄청난 균형 감각이 필요하죠.
 &lt;br/&gt;
 저희 팀원들은 균형을 잡기위해 노력하는 보더처럼 굉장히 수평적인 관계를 지향하며 서로의 눈높이를 맞추어 가면서 일을 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/77140019/11.jpeg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 상하 관계에서 누구의 지시로 일하는 것이 아니라, 스스로 일을 찾아 자율성과 높은 책임 의식 하에서 일을 합니다.
 &lt;br/&gt;
 직급에 상관없이 각자 맡은 업무는 본인이 리더가 될 수 있도록 존중해 주는 것이죠.
 &lt;br/&gt;
 팀 회의에서는 서로 신뢰를 바탕으로 누구나 자유롭게 의견을 낼 수 있고, 또 기분좋게 설득 당하기도 합니다.
&lt;/p&gt;
&lt;p&gt;
 마케팅팀 뿐만 아니라 오픈소스컨설팅에는 '님 문화'가 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이는 나이와 직급에 상관없이, 각자 업무의 전문가로서 서로 존중한다는 의미를 갖고 있고 실제로 능력만 있다면 누구나 리더로서의 기회가 열려 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Thu, 30 May 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/05/30/77140019/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/30/77140019/</guid>
        
        <category>오픈소스컨설팅</category>
        
        <category>마케팅팀</category>
        
        <category>격주4일제</category>
        
        <category>복리후생</category>
        
        <category>롯데월드</category>
        
        <category>워크샵</category>
        
        
      </item>
    
      <item>
        <title>간단한 AWX 설치 및 기본 사용방법</title>
        <description>&lt;p&gt;
 AWX는 Redhat Ansible Tower의 Community 버전으로써 GUI 환경에서 Ansible 스크립트를 수행할 수 있는 장점이 있습니다
&lt;/p&gt;
&lt;p&gt;
 본문의 내용은 AWX의 설치 및 간단한 사용방법에 대한 내용을 다룹니다
&lt;/p&gt;
&lt;h1 id=&quot;id-간단한AWX설치및기본사용방법-TestServer구성&quot;&gt;
 &lt;strong&gt;
  Test Server 구성
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;div class=&quot;panel conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;panelContent&quot;&gt;
  &lt;p&gt;
   본문에서의 테스트 환경은 Openstack 환경의 Centos7.3 기준으로 구축되었으며 IP주소(Floating IP)는 임의로 지정합니다
  &lt;/p&gt;
  &lt;ul&gt;
   &lt;li&gt;
    ansible1 192.168.11.35
   &lt;/li&gt;
   &lt;li&gt;
    ansible2 192.168.11.44
   &lt;/li&gt;
   &lt;li&gt;
    ansible3 192.168.11.45
   &lt;/li&gt;
  &lt;/ul&gt;
  &lt;hr/&gt;
  &lt;ol&gt;
   &lt;li&gt;
    &lt;strong&gt;
     ansible1 서버에서 centos 계정으로 암호없이 ansible2와 ansible3에 접속 가능하도록 설정
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      /etc/hosts 파일에 위 내용을 등록합니다
     &lt;/li&gt;
     &lt;li&gt;
      ansible2와 ansible3 서버에 접속 후, 다음 파일을 수정합니다(해당 내용이 이미 반영되어 있을 경우엔 수정하지 않아도 무관)
      &lt;ol&gt;
       &lt;li&gt;
        #/etc/ssh/sshd_config
        &lt;ol&gt;
         &lt;li&gt;
          PasswordAuthentication yes
         &lt;/li&gt;
         &lt;li&gt;
          저장 후 centos 계정의 암호를 설정합니다
         &lt;/li&gt;
         &lt;li&gt;
          passwd centos
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
     &lt;li&gt;
      ansible1 서버에서 다음 명령을 통해 ssh-copy-id 적용 후 centos계정으로 ansible2와 ansible3서버에 암호입력 없이 접속 가능한지 확인합니다
      &lt;ol&gt;
       &lt;li&gt;
        #ssh-copy-id centos@ansible2
       &lt;/li&gt;
       &lt;li&gt;
        #ssh-copy-id centos@ansible3
       &lt;/li&gt;
       &lt;li&gt;
        #ssh centos@ansible2
       &lt;/li&gt;
       &lt;li&gt;
        #ssh centos@ansible3
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;strong&gt;
     Ansible 및 AWX 설치
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      작성일 기준으로 Ansible 2.7.10, AWX 4.0 버전을 ansible1서버에 설치합니다
     &lt;/li&gt;
     &lt;li&gt;
      패키지 설치
      &lt;ol&gt;
       &lt;li&gt;
        &lt;p&gt;
         #sudo yum install epel-release
        &lt;/p&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;p class=&quot;p1&quot;&gt;
         #sudo yum install git gettext ansible docker nodejs npm gcc-c++ bzip2 -y
        &lt;/p&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;p&gt;
         #sudo yum install python-pip -y
        &lt;/p&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;p class=&quot;p1&quot;&gt;
         #sudo yum install python-docker-py -y
        &lt;/p&gt;
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Docker 실행
      &lt;ol&gt;
       &lt;li&gt;
        &lt;p class=&quot;p1&quot;&gt;
         #sudo systemctl start docker
        &lt;/p&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;p class=&quot;p1&quot;&gt;
         #sudo systemctl enable docker
        &lt;/p&gt;
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;s1&quot;&gt;
       AWX Clone 및 설정
      &lt;/span&gt;
      &lt;br/&gt;
      &lt;ol&gt;
       &lt;li&gt;
        &lt;p class=&quot;p1&quot;&gt;
         &lt;span class=&quot;s1&quot;&gt;
          #git clone
          &lt;span class=&quot;s2&quot;&gt;
           &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/ansible/awx.git&quot; rel=&quot;nofollow&quot;&gt;
            https://github.com/ansible/awx.git
           &lt;/a&gt;
          &lt;/span&gt;
         &lt;/span&gt;
        &lt;/p&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;p class=&quot;p1&quot;&gt;
         #cd awx/installer/
        &lt;/p&gt;
       &lt;/li&gt;
       &lt;li&gt;
        #vim inventory
        &lt;ol&gt;
         &lt;li&gt;
          postgres_data_dir=/opt/awxdb
         &lt;/li&gt;
         &lt;li&gt;
          docker_compose_dir=/opt/awxcompose
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
       &lt;li&gt;
        #sudo mkdir /opt{awxdb,awxcompose}
       &lt;/li&gt;
       &lt;li&gt;
        inventory 설정 중 AWX 버전 설정이 필요하다면 다음 부분을 수정합니다(설정 안할 시 latest로 설치)
        &lt;br/&gt;
        &lt;ol&gt;
         &lt;li&gt;
          dockerhub_base=ansible
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
       &lt;li&gt;
        inventory 설정 중 proxy가 필요하다면 다음 부분을 수정합니다
        &lt;ol&gt;
         &lt;li&gt;
          # Proxy
         &lt;/li&gt;
         &lt;li&gt;
          #http_proxy=
          &lt;span class=&quot;nolink&quot;&gt;
           &lt;a class=&quot;external-link&quot; href=&quot;http://proxy:3128&quot; rel=&quot;nofollow&quot;&gt;
            http://proxy:3128
           &lt;/a&gt;
          &lt;/span&gt;
         &lt;/li&gt;
         &lt;li&gt;
          #https_proxy=
          &lt;span class=&quot;nolink&quot;&gt;
           &lt;a class=&quot;external-link&quot; href=&quot;http://proxy:3128&quot; rel=&quot;nofollow&quot;&gt;
            http://proxy:3128
           &lt;/a&gt;
          &lt;/span&gt;
         &lt;/li&gt;
         &lt;li&gt;
          #no_proxy=
          &lt;a class=&quot;external-link&quot; href=&quot;http://mycorp.org&quot; rel=&quot;nofollow&quot;&gt;
           mycorp.org
          &lt;/a&gt;
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
       &lt;li class=&quot;li1&quot;&gt;
        설정파일의 설정이 완료될 경우 다음 명령을 수행하여 docker-compose파일을 생성합니다
        &lt;ol&gt;
         &lt;li class=&quot;li1&quot;&gt;
          #ansible-playbook -i inventory install.yml
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
       &lt;li class=&quot;li1&quot;&gt;
        위 명령 수행 시 다음과 같은 에러가 발생 가능할 수 있습니다
        &lt;ol&gt;
         &lt;li class=&quot;li1&quot;&gt;
          TASK [local_docker : Start the containers] *************************************************************************************************************************************
          &lt;ol&gt;
           &lt;li class=&quot;li1&quot;&gt;
            fatal: [localhost]: FAILED! =&amp;gt; {&quot;changed&quot;: false, &quot;msg&quot;: &quot;Failed to import docker or docker-py - No module named docker. Try `pip install docker` or `pip install docker-py` (Python 2.6)&quot;
           &lt;/li&gt;
          &lt;/ol&gt;
         &lt;/li&gt;
         &lt;li class=&quot;li1&quot;&gt;
          &lt;span class=&quot;s1&quot;&gt;
           위 에러가 발생할 경우 다음 명령을 수행한 뒤 다시 playbook을 수행합니다
          &lt;/span&gt;
          &lt;ol&gt;
           &lt;li class=&quot;li1&quot;&gt;
            #pip install docker
           &lt;/li&gt;
           &lt;li class=&quot;li1&quot;&gt;
            #pip install docker-compose
           &lt;/li&gt;
          &lt;/ol&gt;
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
       &lt;li class=&quot;li1&quot;&gt;
        install.yml을 수행 시 docker-compose 파일이 다음의 위치에 생성되게 됩니다
        &lt;ol&gt;
         &lt;li&gt;
          #cd /opt/awxcompose/
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
       &lt;li&gt;
        만들어진 docker-compose파일을 다음 명령을 통해 실행합니다(docker-compose 명령 사용 시 특정 파일을 지정하지 않을 경우 자동으로 docker-compose.yml 이름을 가진 파일을 수행)
        &lt;ol&gt;
         &lt;li class=&quot;li1&quot;&gt;
          #docker-compose up -d
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;strong&gt;
     AWX 접속 확인
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      &lt;span class=&quot;nolink&quot;&gt;
       &lt;a class=&quot;external-link&quot; href=&quot;http://192.168.11.35&quot; rel=&quot;nofollow&quot;&gt;
        http://192.168.11.35
       &lt;/a&gt;
       로 접속 시 다음과 같은 화면을 확인가능하며 admin / password로 접속합니다
      &lt;/span&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/0.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
  &lt;/ol&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h1 class=&quot;auto-cursor-target&quot; id=&quot;id-간단한AWX설치및기본사용방법-AWX기본사용법&quot;&gt;
 &lt;strong&gt;
  AWX 기본 사용법
 &lt;/strong&gt;
&lt;/h1&gt;
&lt;div class=&quot;panel conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;panelContent&quot;&gt;
  &lt;ol&gt;
   &lt;li&gt;
    &lt;strong&gt;
     Credential 설정
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      좌측 패널의 Credential 클릭 후 + 로 새 Credential 추가합니다
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/1.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
     &lt;li&gt;
      다음 필드 내용을 추가합니다
      &lt;ol&gt;
       &lt;li&gt;
        NAME: 임의의 Credential 이름
       &lt;/li&gt;
       &lt;li&gt;
        CREDENTIAL TYPE: Machine
       &lt;/li&gt;
       &lt;li&gt;
        USERNAME: ansible1 서버 접속 계정
       &lt;/li&gt;
       &lt;li&gt;
        SSH PRIVATE KEY: 키로 접속한는 경우에 사용하며 Key가 아닌 암호로 접속할 경우 위의 비밀번호를 넣어서 Save
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/2.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
     &lt;li&gt;
      Key를 직접 입력하거나 pem 파일등을 드래그 앤 드롭으로 넣어도 가능합니다
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;strong&gt;
     Inventory 설정
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      좌측 패널의 Inventories 클릭 및 + 로 새로운 Inventory를 생성합니다 (Smart가 아닌 일반 inventory로 생성)
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/3.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
     &lt;li&gt;
      다음 필드 내용을 추가합니다
      &lt;ol&gt;
       &lt;li&gt;
        NAME: 임의의 Inventory 이름
       &lt;/li&gt;
       &lt;li&gt;
        ORGANIZTION: Default
       &lt;/li&gt;
       &lt;li&gt;
        &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
         &lt;img src=&quot;/assets/images/77138487/4.png&quot;/&gt;
        &lt;/span&gt;
       &lt;/li&gt;
       &lt;li&gt;
        Inventory 생성 시 HOSTS 탭을 사용 가능하며 + 를 눌러서 Host를 등록합니다
       &lt;/li&gt;
       &lt;li&gt;
        &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
         &lt;img src=&quot;/assets/images/77138487/5.png&quot;/&gt;
        &lt;/span&gt;
       &lt;/li&gt;
       &lt;li&gt;
        ansible2를 다음과 같이 등록하며 같은 방법으로 ansible3도 등록합니다
       &lt;/li&gt;
       &lt;li&gt;
        &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
         &lt;img src=&quot;/assets/images/77138487/6.png&quot;/&gt;
        &lt;/span&gt;
       &lt;/li&gt;
       &lt;li&gt;
        다음과 같이 ansible2를 선택 후 run commands 클릭합니다
       &lt;/li&gt;
       &lt;li&gt;
        &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
         &lt;img src=&quot;/assets/images/77138487/7.png&quot;/&gt;
        &lt;/span&gt;
       &lt;/li&gt;
       &lt;li&gt;
        다음 내용을 통해 확인합니다
        &lt;ol&gt;
         &lt;li&gt;
          MODULE: ping
         &lt;/li&gt;
         &lt;li&gt;
          MACHINE CREDENTIAL: AWX Admin Credential
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
       &lt;li&gt;
        &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
         &lt;img src=&quot;/assets/images/77138487/8.png&quot;/&gt;
        &lt;/span&gt;
       &lt;/li&gt;
       &lt;li&gt;
        LAUNCH클릭 시 정상적으로 수행될 경우 다음과 같은 화면이 출력됩니다
       &lt;/li&gt;
       &lt;li&gt;
        &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
         &lt;img src=&quot;/assets/images/77138487/9.png&quot;/&gt;
        &lt;/span&gt;
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;strong&gt;
     Project 생성
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      일반적으로 git을 사용하나 내부 테스트용으로 Manual로 생성해봅니다
     &lt;/li&gt;
     &lt;li&gt;
      생성 시 다음처럼 프로젝트를 만들 수 없음을 확인할 수 있습니다
      &lt;ol&gt;
       &lt;li&gt;
        &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
         &lt;img src=&quot;/assets/images/77138487/10.png&quot;/&gt;
        &lt;/span&gt;
       &lt;/li&gt;
       &lt;li&gt;
        /var/lib/awx/projects내에 디렉토리를 만들어도 인식하지 않음을 알 수 있으며,  inventory 설정 중 다음 부분의 수정 및 재배포가 필요합니다
       &lt;/li&gt;
       &lt;li&gt;
        재배포하더라도 기존 설정이 초기화되지는 않습니다
        &lt;ol&gt;
         &lt;li&gt;
          #vim /centos/awx/installer/inventory
          &lt;ol&gt;
           &lt;li&gt;
            project_data_dir= /var/lib/awx/projects
           &lt;/li&gt;
          &lt;/ol&gt;
         &lt;/li&gt;
         &lt;li&gt;
          디렉토리를 default인 /var/lib/awx/projects가 아닌 임의의 디렉토리 /opt/awx/projects 등으로 지정해도 무관하며 본문에서는 임의의 디렉토리를 사용합니다
         &lt;/li&gt;
         &lt;li&gt;
          /centos/awx/installer에서 ansible-playbook -i inventory install.yml 명령을 수행합니다
         &lt;/li&gt;
         &lt;li&gt;
          vim /opt/awxcompose/docker-compose.yml 명령으로 내용 확인 시 다음 부분이 추가된 것을 확인할 수 있습니다
          &lt;ol&gt;
           &lt;li&gt;
            &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
             &lt;img src=&quot;/assets/images/77138487/11.png&quot;/&gt;
            &lt;/span&gt;
           &lt;/li&gt;
          &lt;/ol&gt;
         &lt;/li&gt;
         &lt;li&gt;
          이제 /opt/awx/projects에 디렉토리를 생성 후 새로고침 시 다음처럼 프로젝트 추가가 가능한 것을 확인할 수 있습니다
          &lt;ol&gt;
           &lt;li&gt;
            &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
             &lt;img src=&quot;/assets/images/77138487/12.png&quot;/&gt;
            &lt;/span&gt;
           &lt;/li&gt;
          &lt;/ol&gt;
         &lt;/li&gt;
         &lt;li&gt;
          동작을 테스트해보기 위해 test_project 디렉토리 내에 간단한 playbook을 생성합니다
          &lt;ol&gt;
           &lt;li&gt;
            vim /opt/awx/projects/test_project/fact.yml
           &lt;/li&gt;
           &lt;li&gt;
            &lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
             &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
              &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: java; gutter: false; theme: Confluence&quot; data-theme=&quot;Confluence&quot;&gt;---
- hosts: all
  tasks:
    - name: Print Facts
      debug:
        msg:
          - Default Hostname is 
          - Default IPV4 of  is &lt;/pre&gt;
             &lt;/div&gt;
            &lt;/div&gt;
           &lt;/li&gt;
           &lt;li&gt;
            yml 파일을 생성 후 Test_project에서 JOB TEMPLATES탭을 클릭하여 Job Template을 추가합니다
           &lt;/li&gt;
           &lt;li&gt;
            &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
             &lt;img src=&quot;/assets/images/77138487/13.png&quot;/&gt;
            &lt;/span&gt;
           &lt;/li&gt;
           &lt;li&gt;
            &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
             &lt;img src=&quot;/assets/images/77138487/14.png&quot;/&gt;
            &lt;/span&gt;
           &lt;/li&gt;
           &lt;li&gt;
            위 화면에서 Save 이후 바로 LAUNCH를 클릭하거나 좌측 패널의 TEMPLATES메뉴에서 새로 만든 템플릿의 Start job 아이콘을 클릭합니다
           &lt;/li&gt;
           &lt;li&gt;
            &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
             &lt;img src=&quot;/assets/images/77138487/15.png&quot;/&gt;
            &lt;/span&gt;
           &lt;/li&gt;
           &lt;li&gt;
            &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
             &lt;img src=&quot;/assets/images/77138487/16.png&quot;/&gt;
            &lt;/span&gt;
           &lt;/li&gt;
           &lt;li&gt;
            정상적으로 동작 시 위와 같이 완료되며 TEMPLATE 화면에서 녹색으로 표시되는 것을 확인할 수 있습니다
           &lt;/li&gt;
           &lt;li&gt;
            &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
             &lt;img src=&quot;/assets/images/77138487/17.png&quot;/&gt;
            &lt;/span&gt;
           &lt;/li&gt;
          &lt;/ol&gt;
         &lt;/li&gt;
        &lt;/ol&gt;
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
  &lt;/ol&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;panel conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;
  &lt;b&gt;
   암호화 파일 실행
  &lt;/b&gt;
 &lt;/div&gt;
 &lt;div class=&quot;panelContent&quot;&gt;
  &lt;ol&gt;
   &lt;li&gt;
    &lt;strong&gt;
     Ansible Vault 란
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      Ansible에는 playbook 파일을 암호화할 수 있는 ansible vault라는 기능을 제공하며, 해당 기능으로 암호화 시 암호를 입력해야만 해당 playbook을 수행할 수 있게됩니다
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;strong&gt;
     Vault로 암호화된 playbook 실행
    &lt;/strong&gt;
    &lt;ol&gt;
     &lt;li&gt;
      일반적으로 group_vars/all 등 playbook에 사용되는 변수들에 대해 암호화하나 간단한 테스트를 위해 기존 playbook을 복사 후 encrypt합니다
      &lt;ol&gt;
       &lt;li&gt;
        cd /opt/awx/projects/test_project
       &lt;/li&gt;
       &lt;li&gt;
        cp fact.yml secfact.yml
       &lt;/li&gt;
       &lt;li&gt;
        ansible-vault encrypt secfact.yml
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
     &lt;li&gt;
      vi 편집기 등으로 secfact.yml을 열어볼 경우 암호화되어 내용을 확인할 수 없으며, 내용 확인을 위해서는 다음 명령을 통해 암호를 입력해야합니다
      &lt;ol&gt;
       &lt;li&gt;
        ansible-vault view secfact.yml
       &lt;/li&gt;
      &lt;/ol&gt;
     &lt;/li&gt;
     &lt;li&gt;
      테스트를 위해 AWX에 접속 후 Job Template을 생성하여 실행 시 다음과 같은 에러를 확인 가능합니다
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/18.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
     &lt;li&gt;
      credential 메뉴에서 다음과 같이 새로운 Vault type의 credential을 생성합니다
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/19.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
     &lt;li&gt;
      생성 후 Job Template에 새로 만들어진 Vault Credential를 추가합니다
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/20.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
     &lt;li&gt;
      다시 실행 시 다음처럼 정상적으로 수행됨을 확인할 수 있습니다
     &lt;/li&gt;
     &lt;li&gt;
      &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
       &lt;img src=&quot;/assets/images/77138487/21.png&quot;/&gt;
      &lt;/span&gt;
     &lt;/li&gt;
    &lt;/ol&gt;
   &lt;/li&gt;
  &lt;/ol&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;panel conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;
  &lt;b&gt;
   후기
  &lt;/b&gt;
 &lt;/div&gt;
 &lt;div class=&quot;panelContent&quot;&gt;
  &lt;p&gt;
   Ansible 초보의 입장에서 느낀 점으로는 우선 GUI에서 오는 가시성은 꽤나 편리했습니다.(예를 들어 ping test부분이라던가) 특히 Admin의 입장에서라면 이미 모든 설정이 되어있다고 가정할 시 관리적인 측면에서 일반 Ansible에 비해 편하게 사용이 가능하구요.
  &lt;/p&gt;
  &lt;p&gt;
   다만 기본 Ansible외에 AWX의 설치 및 설정에 대한 관리포인트의 증가 및 AWX내에서 yml파일을 생성할 수 없는 점, 실제 운영환경에서의 제약사항등을 고려 시 Ansible에 숙달될수록 AWX의 필요성을 덜 느낄 것으로 생각됩니다.
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;panel conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;panel&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;
  &lt;b&gt;
   References
  &lt;/b&gt;
 &lt;/div&gt;
 &lt;div class=&quot;panelContent&quot;&gt;
  &lt;ol&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://chhanz.github.io/ansible/2019/01/30/ansible-vault-create-groupvars/&quot; rel=&quot;nofollow&quot;&gt;
     https://chhanz.github.io/ansible/2019/01/30/ansible-vault-create-groupvars/
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/ansible/awx/issues/857&quot; rel=&quot;nofollow&quot;&gt;
     https://github.com/ansible/awx/issues/857
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://www.unixarena.com/2018/11/ansible-tower-awx-how-to-create-manual-scm-project.html/&quot; rel=&quot;nofollow&quot;&gt;
     https://www.unixarena.com/2018/11/ansible-tower-awx-how-to-create-manual-scm-project.html/
    &lt;/a&gt;
   &lt;/li&gt;
   &lt;li&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://docs.ansible.com/ansible/2.4/ansible-vault.html&quot; rel=&quot;nofollow&quot;&gt;
     https://docs.ansible.com/ansible/2.4/ansible-vault.html
    &lt;/a&gt;
   &lt;/li&gt;
  &lt;/ol&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Fri, 24 May 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/05/24/77138487/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/24/77138487/</guid>
        
        
      </item>
    
      <item>
        <title>AWS Summit Seoul 2019 세션 다시보기</title>
        <description>&lt;p&gt;
 안녕하세요, 오픈소스컨설팅입니다.
&lt;/p&gt;
&lt;p&gt;
 지난 4월 17-18일 코엑스에서 AWS Summit Seoul 2019 행사가 개최되었는데요,
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅도 이 행사에 Silver 스폰서로 참여하였습니다!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot; style=&quot;color: rgb(23,43,77);&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/75825367/0.jpeg&quot;/&gt;
  &lt;/span&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/75825367/1.jpeg&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그리고 스폰서 세션 참가도 진행하였으며, 최지웅님이 발표한 강연장에는 무려 400명이 넘는 분들이 참석하시어 뜨거운 관심을 보내주셨습니다.
&lt;/p&gt;
&lt;p&gt;
 이와 더불어 Expo 부스에서는 본 세션에서 소개된
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.play-ce.io/&quot; rel=&quot;nofollow&quot;&gt;
  '고객 시스템 환경에 최적화된 클라우드 솔루션 - Playce'
 &lt;/a&gt;
 를 직접 데모로 보여주는 자리도 마련하였습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이번 포스팅에서는 세션장이 넘칠만큼 주목을 받았던
 &lt;strong&gt;
  &quot;4시간 안에 끝내는 AWS 클라우드 전환 및 운영 환경 구성&quot;
 &lt;/strong&gt;
 내용에 대해 공유하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/75825367/2.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/75825367/3.jpeg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;AWSSummitSeoul2019세션다시보기-Introduction&quot;&gt;
 Introduction
&lt;/h2&gt;
&lt;p&gt;
 오픈소스컨설팅은 가상화, 클라우드 컨설팅, 서비스 아키텍처 등 최신 오픈소스 기술에 대해 주로 전파하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 발표자인 최지웅님은 2012년 오픈소스컨설팅을 설립하였고, 7년간 오픈소스 관련된 비즈니스 컨설팅, 구축사업, 기술지원을 수행하고 있으며 어떻게 하면 동료들과 좋은 회사를 만들지 지금까지도 고민하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 많은 분들이 대체 오픈소스 비즈니스를 하면서 어떻게 돈을 버는지 궁금해 하시는데, 답변을 드리자면 오픈소스는 연간 Subscription service fee와 Open source packaging 을 통해 수익을 창출하는 비즈니스입니다.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅은 자사가 판매하는 커뮤니티 기반의 오픈소스 소프트웨어 수익의 45%는 회사가, 45%는 커뮤니티에, 10%는 봉사단체에 기부하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 오픈소스와 회사가 가진 핵심 가치 중 하나가 바로 &quot;공유&quot;이기 때문입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;AWSSummitSeoul2019세션다시보기-Migration방식의변화&quot;&gt;
 Migration 방식의 변화
&lt;/h2&gt;
&lt;p&gt;
 클라우드는 거부할 수 없는 거대한 IT 메가 트렌드로서, 특히 최근 공공, 금융분야에서 퍼블릭 클라우드를 허용하면서 많은 업체들이 클라우드로 전환을 고려하는 추세입니다.
&lt;/p&gt;
&lt;p&gt;
 그러한 측면에서 엔터프라이즈는 기존의 유닉스 시스템을 어떻게 전환할 것인가에 대한 고민이 점점 많아지고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 현재를 비유하기 위해 예전의 시절로 돌아가 보면 인력거를 끌며 이사하던 때가 있었습니다. 오늘 날 그러한 방식이 포장 이사로 변화한 것 처럼
&lt;/p&gt;
&lt;p&gt;
 인프라의 이주도 직접 서버와 랙을 x86 기반으로 전환하던 것에서 소프트웨어 기반의 포장이사, 즉  컨테이너 방식으로 바뀌어 가고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이는 기존 환경을 그대로 클라우드 환경으로 손쉽게 이주하려는 니즈에서 발생한 것인데요,
&lt;/p&gt;
&lt;p&gt;
 예를 들면 베어메탈 기반의 운영체제나 VM웨어 등의 가상화를 사용하고 있는 고객이 VPN 또는 Direct Connect를 활용하여 AWS 퍼블릭 클라우드에 그대로 옮겨 편리하게 이용하려는 수요가 있는 것입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 현재의 업무 시스템은 그 복잡도가 점점 커져가고 있으며, 이를 다양한 서버 환경에 빌드, 배포, 운영을 하기 때문에 그 무엇보다 이동성이 중요해지게 되었고 그로 인해 컨테이너가 각광받고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 즉 퍼블릭 클라우드, 멀티 클라우드, 프라이빗 클라우드 등 환경에 상관 없이, 개인이 구동하는 업무 시스템의 이동성과 연결성이 현재의 시스템에서 가장 중요하다고 볼 수  있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/75825367/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;AWSSummitSeoul2019세션다시보기-Migration시가장중요한요소&quot;&gt;
 Migration 시 가장 중요한 요소
&lt;/h2&gt;
&lt;p&gt;
 마이그레이션 할 때 고려해야 할 중요한 요소는 해당 시스템의 용도(애플리케이션 서버인지 DB 서버인지)와 용량, 난이도 등이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 굉장히 다양한 업무가 서로 다른 언어로 개발되어 운영되고 있는데 일반적으로 리눅스용 C로 변환하는 경우는 재컴파일이 필요한 경우나, 데이터베이스가 이기종으로 바뀌는 형태는 집이 바뀌는 형태로 난이도가 높다고 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 마이그레이션은 대부분 사람이 직접 진행을 하게 되는데 실제 문제는 대부분 이 사람으로부터 시작합니다.
&lt;/p&gt;
&lt;p&gt;
 결국은 마이그레이션의 가장  중요한 요소는 사람이라 할 수 있죠.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 많은 기업들이 재해복구 체계를 갖추기 위하여 기본적인 도구를 구매하여 운영하고 있습니다. 사실 클라우드 마이그레이션 솔루션을 공급하는 다른 회사들은 기본적으로 재해복구(DR) 솔루션으로부터 시작되었습니다.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅이 개발한 클라우드 마이그레이션 도구
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.play-ce.io/roro/&quot; rel=&quot;nofollow&quot;&gt;
  Playce RoRo
 &lt;/a&gt;
 의 클라우드 전환 자동화의 핵심 요소는 아래와 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 1. OS 분석기 – Python
&lt;/p&gt;
&lt;p&gt;
 2. 원본 OS 스냅샷 – dd
&lt;/p&gt;
&lt;p&gt;
 3. Raw 파일 아마존AWS 전송 – compress scp
&lt;/p&gt;
&lt;p&gt;
 4. 볼륨 이미지 저장소 – Amazon S3
&lt;/p&gt;
&lt;p&gt;
 5. AMI 구성 – AWS SDK API
&lt;/p&gt;
&lt;p&gt;
 6. OS 생성 - AWS SDK API
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/75825367/5.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;h6 id=&quot;AWSSummitSeoul2019세션다시보기-&amp;lt;PlayceRoRo코어이미지생성프로세스&amp;gt;&quot;&gt;
 &amp;lt;Playce RoRo 코어 이미지 생성 프로세스&amp;gt;
&lt;/h6&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;AWSSummitSeoul2019세션다시보기-클라우드네이티브&quot;&gt;
 클라우드 네이티브
&lt;/h2&gt;
&lt;p&gt;
 이전에 리눅스 시스템은 하드웨어 가격이 비싼 형태였으나, 현재의 클라우드 시스템은 소프트웨어의 비용이 하드웨어의 비용을 초과하는 상황이 벌어지고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 결국 많은 고객사들이 소프트웨어 비용을 줄이기 위해 오픈소스로 전환을 고려할 수 밖에 없게 되는 현실입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 클라우드 네이티브는 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식으로 업무 시스템 하나를 작게 쪼개고, 요청이 많을 때 스케일 아웃 형태로 유연하게 대응하자는 전략입니다.
&lt;/p&gt;
&lt;p&gt;
 분산을 통한 유연성을 확보할 수 있다는 장점이 있으나, 운영 관점에서는 애플리케이션도 분산시켜야 하는 단점도 있습니다. 분산은 인스턴스 증가를 의미하고, 이는 소프트웨어의 비용의 증가를 의미합니다.
&lt;/p&gt;
&lt;p&gt;
 비용을 줄이기 위해서는 오픈소스를 적극 도입하고 내재화할 필요가 있습니다. CNCF(Cloud Native Computing Foundation)는 클라우드 네이티브 컴퓨팅을 보편적이고 지속 가능하게 만드는 오픈소스 소프트웨어 재단인데,
&lt;/p&gt;
&lt;p&gt;
 여기서는 클라우드 환경의 각 레이어에 속하는 솔루션 컴포넌트를 제안하고 맵을 그려 고객사의 이해를 돕도록 하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;AWSSummitSeoul2019세션다시보기-오픈소스미들웨어&quot;&gt;
 오픈소스 미들웨어
&lt;/h2&gt;
&lt;p&gt;
 비용 절감을 위해서는 현재 인프라에 구축되어 있는 AS-IS 소프트웨어도 오픈소스로 전환이 필요합니다. 가장 보편적으로 사용되는 것이 미들웨어이며, 전세계적으로 Apache Tomcat이 가장 많이 사용되는데
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.play-ce.io/wasup/&quot; rel=&quot;nofollow&quot;&gt;
  Playce WASup
 &lt;/a&gt;
 은 오픈소스 기반의 미들웨어인 Tomcat의 운영관리, 웹서버 연결, 도메인 기반 서버 및 클러스터 관리를 지원하도록 설계된 제품입니다.
&lt;/p&gt;
&lt;p&gt;
 기존의 클러스터 시스템을 AWS 클라우드 환경으로 이전하였을 때 스케일 아웃을 대응할 수 없다는 단점이 있는데 Playce WASup은 이를 보완하면서 중앙 집중형 업무 시스템 관리를 할 수 있도록 구현한 솔루션입니다.
&lt;/p&gt;
&lt;p&gt;
 현재 개발된 저희 솔루션은 GS인증 단계를 진행하고 있으며, 일부 고객사에서 CBT(Closed Beta Test)와 PoC를 진행하고 있는 상태입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅의 슬로건은 Sharing Technology, Growing Together 입니다.
&lt;/p&gt;
&lt;p&gt;
 가지고 있는 모든 기술을 공유하며 함께 성장해 나가고자 합니다.
&lt;/p&gt;
&lt;p&gt;
 물론 본 세션의 발표자료도 아래 링크를 통해 다운로드 받으실 수 있습니다. ^^
&lt;/p&gt;
&lt;p&gt;
 클라우드 및 오픈소스와 관련하여 도움이 필요하시면 언제든지 오픈소스컨설팅에 말씀해주세요
 &lt;span&gt;
  !
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://track.maillink.co.kr/procresponse?a=1I-14692004I-40I-4goaSoZE-8zPqrCF-130858940I-4ehhgzE-8D-7D-7DDDD-6zaSJPzeBuPD-6HPhD-7OgPHRCUuoPfCHzUahSHED-74D-5BDzI-3&quot; name=&quot;m_-1102158338673484377_ANCHOR31637931&quot; rel=&quot;nofollow&quot; style=&quot;text-align: center;&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/75825367/6.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/75825367/7.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/75825367/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.play-ce.io/roro/&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/75825367/9.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://www.play-ce.io/wasup/&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/75825367/10.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Wed, 08 May 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/05/08/75825367/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/05/08/75825367/</guid>
        
        
      </item>
    
      <item>
        <title>오픈소스컨설팅, Atlassian meets DevOps and ITSM을 개최하다!</title>
        <description>&lt;p&gt;
 &lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;false&quot; data-macro-name=&quot;include&quot;&gt;
  안녕하세요!!!
  &lt;p&gt;
   오픈소스컨설팅 마케터 박현수입니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   지난 4월 19일, Atlassian 솔루션을 활용한 DevOps 및 ITSM Best Practice라는 주제로 오픈소스컨설팅이 주최하고, 아틀라시안이 후원하는 &quot;Atlassian meets DevOps and ITSM&quot; 행사가 열렸습니다.
  &lt;/p&gt;
  &lt;p&gt;
   큰 행사의 직후였음에도 불구하고, 정말 많은 고객 분들이 참석해주셔서 저희도 깜짝 놀랐어요!
  &lt;/p&gt;
  &lt;p&gt;
   성원에 진심으로 감사드리고, 앞으로도 더욱 노력하는 오픈소스컨설팅이 되겠습니다. 지켜봐주세요~
  &lt;/p&gt;
  &lt;p&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/71801513/0.png&quot;/&gt;
   &lt;/span&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/71801513/1.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;span style=&quot;color: rgb(165,173,186);&quot;&gt;
    &lt;sup&gt;
     (왼쪽부터 오픈소스컨설팅 한진규 이사, 카카오 이호정 셀장, 아틀라시안 Scott Davis SA, 통역사, 오픈소스컨설팅 최지웅 부사장)
    &lt;/sup&gt;
   &lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   음 다소 긴 제목이지만, 이번 세미나의 주제는
   &lt;strong&gt;
    DevOps를 위한 Atlassian 사용 방법
   &lt;/strong&gt;
   정도로 풀어 이야기할 수 있겠네요.
  &lt;/p&gt;
  &lt;p&gt;
   이번 세미나에서 소개된 대부분의 내용은 기술보다는 운영자나 개발자의 마인드셋에 대해 강조하곤 했습니다. (DevOps의 시작은 역시 마음가짐이죠!)
  &lt;/p&gt;
  &lt;p&gt;
   이러한 내용은 오픈소스컨설팅의 CTO이자 정신적 지주를 맡고 계신 최지웅 부사장님의 키노트에서도 확인해볼 수 있었습니다.
  &lt;/p&gt;
  &lt;p&gt;
   &quot;사실 기술이 문제가 아니예요&quot;라는 부제를 달고,
   &lt;strong&gt;
    올바른 DevOps 수행을 위한 인프라 스트럭처 전략
   &lt;/strong&gt;
   을 소개해주셨습니다.
  &lt;/p&gt;
  &lt;h3 id=&quot;id-오픈소스컨설팅,AtlassianmeetsDevOpsandITSM을개최하다!-Atlassian을도입하기전,필수적인고민&quot;&gt;
   Atlassian을 도입하기 전, 필수적인 고민
  &lt;/h3&gt;
  &lt;p&gt;
   DevOps를 위한 도구로서 Atlassian을 도입하기 전, 하부 인프라 스트럭처에 대한 고민이 선행되어야 합니다.
  &lt;/p&gt;
  &lt;p&gt;
   IT 환경에서 중요한 것은 프로젝트에서 프로덕트로, 목표는 안정성에서 민첩성으로 점차 변화하고 있고 그러한 변화의 중심에 DevOps가 있다고 볼 수 있습니다.
  &lt;/p&gt;
  &lt;p&gt;
   Time to Value -  Time to Market : 혁신을 위해서는 작은 단위로 빠르게 배워야 합니다.  너무 많은 기능을 한꺼번에 넣으려 하는 것은 욕심인거죠.
  &lt;/p&gt;
  &lt;p&gt;
   현재의 IT 최고의 인프라스트럭처는 보다 단순하게 연결되어야 하고, &quot;새로운 기술&quot;을 보다 빠른 주기로 제공하는 모델입니다.
  &lt;/p&gt;
  &lt;p&gt;
   조금 기술적인 관점에서 이야기하자면, 애플리케이션을 분할 / 규격화 / 캡슐화해서 Microservice 형태로 개발하여 다양한 운영 환경에 지속적 배포 (Continuous Deploy) 결국, 분산된 환경에 최적화해야 합니다.
  &lt;/p&gt;
  &lt;p&gt;
   스케일 형태로,
   &lt;strong&gt;
    가용성을 위해 분산하는 클라우드 네이티브 환경을 구축하는거죠.
   &lt;/strong&gt;
  &lt;/p&gt;
  &lt;p&gt;
   클라우드 네이티브는 클라우드 컴퓨팅 모델의 장점을 모두 활용하는 애플리케이션을 개발하고 실행하기 위한 접근 방식입니다.
  &lt;/p&gt;
  &lt;p&gt;
   장점은 분산을 통한 유연성을 가져올 수 있지만, 운영 관점에서는 단점도 분명합니다. 애플리케이션도 분산시켜야 하기 때문이죠.  분산은 곧 인스턴스 증가, 인스턴스 증가는 곧 소프트웨어 비용의 증가를 불러옵니다.
  &lt;/p&gt;
  &lt;p&gt;
   이러한 클라우드 네이티브의 단점을 타개하기 위해서는,
   &lt;strong&gt;
    오픈소스를 도입하여 인프라를 만들어야 합니다.
   &lt;/strong&gt;
  &lt;/p&gt;
  &lt;p&gt;
   인프라 스트럭처 단에서는 개발된 코드가 유연하게 물흐르듯 연결된 에코시스템을 구축하고,  조직에서는 프로세스가 잘 조화되도록 알맞은 시스템을 제공해야 합니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;h3 id=&quot;id-오픈소스컨설팅,AtlassianmeetsDevOpsandITSM을개최하다!-DevOps를위한최적의인프라찾기&quot;&gt;
   DevOps를 위한 최적의 인프라찾기
  &lt;/h3&gt;
  &lt;p&gt;
   DevOps로 가기위해서는 Cloud로의 이동은 필연인 것으로 보입니다.  그 근간은 MSA(Microservices Architecture)이며, DevOps + Cloud까지의 조합이 매우 중요합니다.
  &lt;/p&gt;
  &lt;p&gt;
   일부조직에서는 이미  Dev + Ops + Sec + CI/CD 까지 연결하여,  컨테이너용 애플리케이션 빌드가 최종 목표인 방향으로 흘러가고 있습니다.
  &lt;/p&gt;
  &lt;p&gt;
   Trigger Build &amp;amp; Deploy 구성을 살펴보면, 컨테이너에 한데 모아놓고 개발 및 배포에 관한 부분들에 대한 관리가 가능한 것으로 보입니다.
  &lt;/p&gt;
  &lt;p&gt;
   ITS부터 개발, 검증, 빌드하여 컨테이너를 통해 운영까지 보내는 프로세스를 물흐르듯이 연결시키는 것이 중요합니다. 이러한 부분은 직접 쿠버네티스를 사용하거나, PaaS를 통해 구성해낼 수 있습니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;h3 id=&quot;id-오픈소스컨설팅,AtlassianmeetsDevOpsandITSM을개최하다!-엔터프라이즈DevOps까지확장하기&quot;&gt;
   엔터프라이즈 DevOps까지 확장하기
  &lt;/h3&gt;
  &lt;p&gt;
   따라서, 이러한 애플리케이션 구동 환경이 특정 인프라 환경으로 제한되어서는 안됩니다.
   &lt;strong&gt;
    결국 멀티 클라우드
   &lt;/strong&gt;
   에 대한 이야기까지 흘러오게 되는거죠.
  &lt;/p&gt;
  &lt;p&gt;
   프라이빗 및 퍼블릭 환경에서 다 똑같이 구성해야 합니다.  (이 때문에 컨테이너에 대한 부분을 고민하지 않을 수가 없습니다)
  &lt;/p&gt;
  &lt;p&gt;
   재작년부터 고민이 되는 것은, 어떻게 하면 DC를 클라우드로 연결시키는 작업을 할 수 있을까에 대한 부분입니다.  일부 게임사들은 이미 컨테이너를 도입하고 있습니다.
  &lt;/p&gt;
  &lt;p&gt;
   하이브리드 및 멀티 클라우드로 갔을 때 배포 대상은 굉장히 다양합니다. 직접 배포할 수도 있고, 지난주 발표한 것처럼 Google의 Anthos라는 프로그램을 이용할 수도 있습니다.
  &lt;/p&gt;
  &lt;p&gt;
   엔터프라이즈 DevOps까지 확장을 하고자 한다면, 비전, 전략 및 하부 인프라, 오토 메이션, 성능 보안 등 고민할 부분이 상당히 많죠. 기존 인프라 및 각 컴포넌트까지 총체적으로 고민해야 합니다.
  &lt;/p&gt;
  &lt;h3 id=&quot;id-오픈소스컨설팅,AtlassianmeetsDevOpsandITSM을개최하다!-결국에는사람!&quot;&gt;
   결국에는 사람!
  &lt;/h3&gt;
  &lt;p&gt;
   결국 결론은 다시 마인드셋으로 흘러옵니다.  기술력보다는 이를 어떻게 조합하는지가 중요합니다.
  &lt;/p&gt;
  &lt;p&gt;
   따라서, 팀 조직 및 서비스 및 운영 그리고
   &lt;strong&gt;
    결국에는 사람과의 커뮤니케이션
   &lt;/strong&gt;
   이 가장 중요하다는 것을 강조하는 키노트였습니다!
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   키노트 다음으로는 Atlassian의 솔루션 엔지니어
   &lt;strong&gt;
    Scott Goh-Davis (이하, 스캇)의 &quot;ITSM in and Agile World&quot; 세션
   &lt;/strong&gt;
   이 이어졌습니다.
  &lt;/p&gt;
  &lt;h3 id=&quot;id-오픈소스컨설팅,AtlassianmeetsDevOpsandITSM을개최하다!-ForTEAMS!&quot;&gt;
   &lt;strong&gt;
    For TEAMS !
   &lt;/strong&gt;
  &lt;/h3&gt;
  &lt;p&gt;
   스캇은 오랜 경력동안 좋은 팀을 만나고 많은 경험 토대로, 그 경험을 공유하고 ITSM을 이룩하는 방법에 대해서 이야기해주었습니다.
  &lt;/p&gt;
  &lt;p&gt;
   ITSM과 관련해서는 1. 인스턴스 관리 2. 운영 관리 3. 몇가지 Metric에 대한 이야기를 했고, 마지막으로
   &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/whitepapers/itil4&quot; rel=&quot;nofollow&quot;&gt;
    ITSM 백서를 다운로드할 수 있는 링크
   &lt;/a&gt;
   를 공유했습니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   처음 스캇이 개발자로서 일하기 시작했을 때는, 운영에서 나오는 변경 사항을 그때그때 반영해야 했고 그것이 Final QA라고 주장했다고 합니다. 이런 상황은 30년이 지난 지금도 빈번하게 일어나고 있죠.
  &lt;/p&gt;
  &lt;p&gt;
   이를테면, 개발에 있어 Waterfall 방식을 고수하듯, 작은 변경 사항을 빠르게 반영하는 애자일 방법과는 다른 움직임도 아직 만연합니다.
  &lt;/p&gt;
  &lt;p&gt;
   하지만, 요새는 빠른 것뿐만 아니라 퀄리티를 함께 높이는 것이 중요해 DevOps를 넘어서 DevSecOps까지 나와있는 상황입니다.
  &lt;/p&gt;
  &lt;p&gt;
   DevOps와 ITSM이 많은 조직들이 적용하고자 하는 기조이긴 하지만, 개발쪽 변경사항이 더 빨리 자주 발생하면 Operation에서는 리스크라고 받아들일 수도 있습니다. 팀간 장벽이 한층 높아질 수도 있구요.
  &lt;/p&gt;
  &lt;p&gt;
   이러한 상황을 Atlassian은 팀과 문화와 일이 같은 방향으로 함께 움직인다는 미션을 통해 극복하고자 합니다. 각 팀에 맞는 방법과 문화를 개발한 후, 툴과 제품에 대해서 고려하는거죠.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;h3 id=&quot;id-오픈소스컨설팅,AtlassianmeetsDevOpsandITSM을개최하다!-Let'sPLAY!&quot;&gt;
   Let's PLAY!
  &lt;/h3&gt;
  &lt;p&gt;
   사람과 문화 그리고 팀은 어떻게 개선할 수 있을까요? 대부분의 회사는 인사 고과를 받는데, 이러한 인사 고과에 대해서는 익숙하죠. 하지만, 팀에 대해서는 어떨까요?
  &lt;/p&gt;
  &lt;p&gt;
   아틀라시안이 지속적으로 고민하는 것은 팀워크를 어떻게 개선하는가입니다.  왜 팀마다 결과가 다를까요?  그러한 결과를 분석해보기 위해서, Atlassian은
   &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/team-playbook&quot; rel=&quot;nofollow&quot;&gt;
    Atlassian Team Playbook
   &lt;/a&gt;
   을 만들었습니다.  (링크를 통해 다운로드 받을 수 있어요!)
  &lt;/p&gt;
  &lt;p&gt;
   1.
   &lt;strong&gt;
    팀의 현황을 어떻게 측정하는가?
   &lt;/strong&gt;
   - 측정 후 개선 부분을 발견하는 첫단계입니다.
  &lt;/p&gt;
  &lt;p&gt;
   2.
   &lt;strong&gt;
    어떻게 개선할 것인가?
   &lt;/strong&gt;
   개선 아이디어를 도출하고 난 후 실천하는 것을 Atlassian은
   &lt;strong&gt;
    Play
   &lt;/strong&gt;
   라고 부릅니다.
  &lt;/p&gt;
  &lt;p&gt;
   아틀라시안은 이러한 팀플레이북을 매년 1-2번 수행하고 플레이를 통해 개선 및 실천해나가고 있습니다.  특정 아틀라시안 제품에 국한되어서만 사용되는 것은 아니고, 보편적으로 활용할 수 있다고 합니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;strong&gt;
    Genius for managing incidents - Opsgenie
   &lt;/strong&gt;
  &lt;/p&gt;
  &lt;p&gt;
   여러 팀이 가지고 있는 스킬을 어떻게 개선할 수 있을까요? ITSM 이나 애자일에 대해서도 어떻게 접근하고 실천할 수 있을까요?
  &lt;/p&gt;
  &lt;p&gt;
   모던 ITSM에 있어서 가장 이슈가 되는 것은 메이저한 인시던트에 대해서 어떻게 대처하는가 입니다.  인시던트 관리에서 가장 중요한 것은 평균 복구 시간이고,  MTR에서 가장 중요한 것은 반응 (Respond)입니다.
  &lt;/p&gt;
  &lt;p&gt;
   모니터링을 대부분 간과하곤하는데,  중간에 대응 과정에서 Opsgenie라는 제품을 사용해볼 것을 추천드립니다. Opsgenie는 모든 알림을 하나하나 보고, 알람을 봐야하는 적임자에게 전달 및 알림(Alert)을 하는 중간의 허브역할을 수행합니다.
  &lt;/p&gt;
  &lt;p&gt;
   복구는 JSD와 Statuspage를 통해 복구 및 처리 개선을 할 수 있겠습니다. Operation 뿐만 아니라 End user까지 전달될 수 있도록 말이죠.
  &lt;/p&gt;
  &lt;p&gt;
   중간과정에 필요한 Monitoring에서는 Amazon CloudWatch나 Docker 등 고객이 원하는 프로그램을 사용할 수 있습니다.
  &lt;/p&gt;
  &lt;p&gt;
   Opsgenie 이용하면 MTTR을 획기적으로 줄일수 있습니다. 하지만 무엇보다 중요한 것은
   &lt;strong&gt;
    인시턴트 발생 및 대처 이후의 Review
   &lt;/strong&gt;
   라고 스캇은 강조했습니다.
  &lt;/p&gt;
  &lt;p&gt;
   70%나 되는 비율로 인시던트 발생 이후의 대처를 형식적으로 리뷰하고 이 문서를 다른데 두거나 잊혀지고는 합니다. 하지만, 리뷰는 꼼꼼히, 반드시 놓쳐서는 안되는 중요한 과정입니다!
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   1.팀플레이북을 통해 시작해라
  &lt;/p&gt;
  &lt;p&gt;
   2. 전통적인 R&amp;amp;R에 대해 의문을 제기해라.
  &lt;/p&gt;
  &lt;p&gt;
   3. 자동화하라! (Automate with opsgenie)
  &lt;/p&gt;
  &lt;p&gt;
   4. 계속해서 실험하고 적용할 것
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   이후에는 오픈소스컨설팅 한진규 이사님과 카카오 이호정셀장님의 세션이 이어졌습니다.
  &lt;/p&gt;
  &lt;p&gt;
   한진규 이사님은
   &lt;strong&gt;
    &quot;DevOps 문화 구축하기&quot;
   &lt;/strong&gt;
   를 주제로 Atlassian 제품을 활용한 DevOps구성도를 소개해주셨는데요,
  &lt;/p&gt;
  &lt;p&gt;
   아래 그림에서 보듯 Jira를 중심으로 Confluence, Jira Service Desk, Bitbucket 등 도구를 통해 DevOps를 쉽고 간편하게 구축할 수 있습니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/71801513/2.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   아울러, 이전 세션들처럼 DevOps를 위해서 결국에는 &quot;사람&quot;과의 소통이 가장 중요하다고 강조하며,
   &lt;strong&gt;
    &lt;a class=&quot;external-link&quot; href=&quot;https://www.slideshare.net/BrianHan21/devops-134656677?fbclid=IwAR3DCY-AnjafeAU8RYnjgJsFTe9WTF1mQfP1DaseD3MQIaVQXqhTIls1X7c&quot; rel=&quot;nofollow&quot;&gt;
     DevOps 시뮬레이션
    &lt;/a&gt;
   &lt;/strong&gt;
   을 소개했는데요.
  &lt;/p&gt;
  &lt;p&gt;
   DevOps 효과를 직접 경험하고 체득하면서 구성원 한 명 한 명이 DevOps의 실행자가 될 수 있도록 변화시키는 획기적인 시뮬레이션입니다. (위 링크를 통해 DevOps 시뮬레이션을 만나보세요!)
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   KaKao는 Atlassian을 오래 전부터 선구적으로 사용하여, 우리나라에서 DevOps 및 ITSM을 잘 실천하고 있는 회사로 유명하죠.
  &lt;/p&gt;
  &lt;p&gt;
   이호정 셀장님의 &quot;Kakao meets Jira&quot;에서는 말그대로 DevOps의 핵심 툴인 Jira와 kakao가 만난 이야기입니다.
  &lt;/p&gt;
  &lt;p&gt;
   이호정 셀장님이 귀한 시간을 내주셔서 카카오에서 Jira를 어떻게 사용하고 있는지 알아보고, ITSM을 달성하는 방법에 대해서 생생하게 전달받을 수 있었습니다.
  &lt;/p&gt;
  &lt;p&gt;
   특히, 카카오에서 사용 중인 주요 Add-on에 대해서 친절하게 공개해주셔서 많은 고객분들께 참고가 되셨을거라고 생각합니다.
  &lt;/p&gt;
  &lt;p&gt;
   아울러 카카오에서의 업무 요청 처리 예시 프로세스는 마케터인 저한테도 많은 도움이 되었네요
   &lt;img src=&quot;/assets/images/71801513/3.svg&quot;/&gt;
   좋은 발표와 공유에 진심으로 감사드립니다!
  &lt;/p&gt;
  &lt;p&gt;
   모든 발표 내용은
   &lt;a class=&quot;external-link&quot; href=&quot;http://www.osci.kr/board/board.php?b_id=newsletter&amp;amp;cmd=view&amp;amp;num=15&amp;amp;page=0&amp;amp;cate=&amp;amp;eq1=&amp;amp;eq2=&amp;amp;eq3=&amp;amp;eq4=&amp;amp;eq5=&amp;amp;st=&amp;amp;sk=&quot; rel=&quot;nofollow&quot;&gt;
    여기 링크
   &lt;/a&gt;
   에서 확인하실 수 있답니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   세션이 다 끝나고 난 후에는 시원한 맥주와 함께 네트워킹 타임을 가졌답니다!
  &lt;/p&gt;
  &lt;p&gt;
   아틀라시안 본사 직원, 오픈소스컨설팅의 CTO, 실제로 아틀라시안을 도입하신 고객사 셀장님 등 다양한 연사자 분들과 함께 하는 자리여서 많은 분들과 함께 어우러질 수 있어 더욱 좋았습니다!
  &lt;/p&gt;
  &lt;p&gt;
   앞으로도 이런 행사 많이 준비해서 고객 여러분께 더욱 도움이 될 수 있는 오픈소스컨설팅이 되겠습니다.
  &lt;/p&gt;
  &lt;p&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/71801513/4.jpeg&quot;/&gt;
   &lt;/span&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/71801513/5.jpeg&quot;/&gt;
   &lt;/span&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
  &lt;p&gt;
   &lt;br/&gt;
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/p&gt;</description>
        <pubDate>Thu, 25 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/04/25/71801513/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/25/71801513/</guid>
        
        <category>atlassian</category>
        
        <category>itsm</category>
        
        <category>devops</category>
        
        
      </item>
    
      <item>
        <title>2019년 4월 Atlassian User Group Meetup에 다녀오다!</title>
        <description>&lt;p&gt;
 안녕하세요? 오픈소스컨설팅입니다.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅은 Atlassian User Group(AUG) 의 공식 스폰서로 활동하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 (많이들 오세요! 몸만 오시면 됩니다!   )
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  4월 22일 개최된 26번째 아틀라시안 유저 그룹 밋업
 &lt;/strong&gt;
 에 오픈소스컨설팅이 직접 다녀왔습니다!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/71800553/0.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이번  밋업에서는 지난 4월 9일-11일, 라스베가스에서 개최된 역대 최대 규모의 아틀라시안 유저 컨퍼런스인
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &quot;Atlassian Summit 2019&quot;
 &lt;/strong&gt;
 &lt;span&gt;
 &lt;/span&gt;
 에 대한 이야기를 나누었습니다.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅의 한진규 이사님과 AUG의 공동 리더인 디프로그웍스의 신철민 대표님의 발표가 있었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id='id-2019년4월AtlassianUserGroupMeetup에다녀오다!-&quot;아틀라시안서밋2019참석기by한진규이사님&quot;'&gt;
 &quot;아틀라시안 서밋 2019 참석기 by 한진규 이사님&quot;
&lt;/h1&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/71800553/1.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-2019년4월AtlassianUserGroupMeetup에다녀오다!-AtlassianSummit?&quot;&gt;
 Atlassian Summit?
&lt;/h3&gt;
&lt;p&gt;
 3일 동안 진행되는 아틀라시안 서밋, 올해 행사에는 약 5,000여명이 참석하였다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 본 행사가 시작하기 전에 스폰서와 파트너를 위한 전야제가 진행되고
&lt;/p&gt;
&lt;p&gt;
 매일 오전 클라우드와 데이터센터, 서버 등 제품별 업데이트 키노트 세션이 진행된다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 스폰서들이 본인들의 제품을 홍보하는 Expo 부스도 마련되어 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅에서도 한국 파트너사 중 최초로 본 행사의 스폰서로 참여하였는데요,
&lt;/p&gt;
&lt;p&gt;
 유용한 아틀라시안 애드온 제품과 한글을 활용한 기프트로 많은 인기를 끌었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/71800553/2.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 서밋 기간 동안 아틀라시안 직원들이 직접 개발에 참여하는 해커톤 문화인 'Ship it' 행사도 진행되는데
&lt;/p&gt;
&lt;p&gt;
 여기서 개발된 제품이 실제 아틀라시안 제품으로 출시되기도 한다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 마지막날은 Bash라는 네트워킹 파티가 진행됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-2019년4월AtlassianUserGroupMeetup에다녀오다!-ModernIncidentManagement-Opsgenie&quot;&gt;
 Modern Incident Management - Opsgenie
&lt;/h3&gt;
&lt;p&gt;
 서밋이 개막한 첫 날, 아틀라시안의 주요 인사들의 세션이 진행되었습니다.
&lt;/p&gt;
&lt;p&gt;
 그 중  CEO이자  Co-founder인 Scott Farquhar - Digital Transformation를 주제로 키노트를 하였는데요,
&lt;/p&gt;
&lt;p&gt;
 이 발표에서
 &lt;span&gt;
 &lt;/span&gt;
 &lt;strong&gt;
  Opsgenie(옵스지니)
 &lt;/strong&gt;
 에 대한 내용이 심도있게 다루어 졌다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 인시던트나 장애를 잘 관리한다는 것은 내부, 외부 고객과 신뢰를 쌓는 과정으로,
&lt;/p&gt;
&lt;p&gt;
 인시던트가 발생했을 때 얼마나 빨리 원인을 찾고, 해결하는지가 매우 중요한 요소가 되고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 이를 잘 관리하고 운영하는데 아틀라시안 Opsgenie와 Statuspage 제품이 도움이 된다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Atlassian Cloud Usage
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 아틀라시안 제품 중 클라우드 버전을 사용하는 고객이 약 100,000개 기업이라고 합니다.
&lt;/p&gt;
&lt;p&gt;
 전체 아틀라시안 고객이 약 125,000개임을 감안하면, 클라우드를 사용하는 고객의 비율이 상당히 높다는 것을 알 수 있죠.
&lt;/p&gt;
&lt;p&gt;
 현재 아틀라시안 제품을 신규로 도입할 때 90%가 클라우드로 시작한다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 클라우드 제품 자체의 기능이 우수하고, 차세대 프로젝트가 생기면서 지라 어드민에 대한 부담을 줄일 수 있기 때문에
&lt;/p&gt;
&lt;p&gt;
 클라우드에 대한 고객들 선호가 높아지고 있다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이번에 아틀라시안에서 새롭게 발표한 '클라우드 프리미엄' 서비스는
&lt;/p&gt;
&lt;p&gt;
 SLA 99.9% 의 가용성을 보장하고, 언리미티드 스토리지 제공, 프리미엄 서포트 24*7를 지원한다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/71800553/3.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;hr/&gt;
&lt;h1 id='id-2019년4월AtlassianUserGroupMeetup에다녀오다!-&quot;아틀라시안서밋2019참석기by신철민대표님&quot;'&gt;
 &quot;아틀라시안 서밋 2019 참석기 by 신철민 대표님&quot;
&lt;/h1&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/71800553/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 아틀라시안 유저 그룹 공동 리더인 신철민 대표님께서는 서밋의 커뮤니티 워크샵에 대한 리뷰를 해주셨습니다.
&lt;/p&gt;
&lt;p&gt;
 참고로 Atlassian User Group의 명칭이 Atlassian Community 로 명칭이 바뀐다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 AUG Seminar/Meetup 의 명칭도 Atlassian Community Event 바뀔 예정이라고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-2019년4월AtlassianUserGroupMeetup에다녀오다!-ThePowerofHabit&quot;&gt;
 The Power of Habit
&lt;/h3&gt;
&lt;p&gt;
 아틀라시안 커뮤니티 워크샵에서는 '습관의 힘'이라는 책의 내용을 바탕으로 웰커밍 메시지가 진행되었다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 책 '습관의 힘'은 습관을 어떠한 메커니즘으로 만드는지에 대한 내용이 담겨져 있는데요,
&lt;/p&gt;
&lt;p&gt;
 습관을 만들기 위해서는 신호가 발생할 때 반복 행동을 하고 이에 대한 보상 행동을 주라고 합니다.
&lt;/p&gt;
&lt;p&gt;
 이를 3개월동안 반복하면 좋은 습관이 자연스럽게 생긴다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 실제로 신 대표님께서는 이 메커니즘을 통해 매일 메모를 하는 습관을 길렀다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 매일 아침 기상하면(신호) 의자에 앉아 메모장을 펼치고(반복 행동), 세줄만이라도 전날의 행동을 간단히 기록한다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 현재 이 일기장이 5권이나 된다고 하네요. 메모만 봐도 그때를 바로 회상할 수 있고 기억력이 좋아졌다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 좋은 습관을 길르는 것은 생각보다 어렵지 않고, 습관이 한 번 길러지면 이를 빼먹었을 때 인지 부조화 같은 현상이 일어날 정도로 체화된다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h3 id=&quot;id-2019년4월AtlassianUserGroupMeetup에다녀오다!-TheAlignmentChallenge-JiraAlign&quot;&gt;
 The Alignment Challenge - JiraAlign
&lt;/h3&gt;
&lt;p&gt;
 아틀라시안이 최근 애자일 크래프트(AgileCraft)라는 회사를 인수하였는데요,
&lt;/p&gt;
&lt;p&gt;
 애자일 크래프트는 애자일 팀들을 비즈니스 전체로 연결해 관리자들이 프로젝트 진척 상황과 병목 지점을 전체적으로 볼 수 있게 하는 애플리케이션입니다.
&lt;/p&gt;
&lt;p&gt;
 애자일 크래프트는 가트너 매직 쿼드런트(2018)에 &amp;lt;Enterprise Agile Planning Tools&amp;gt; 분야에서 Visionaries 그룹에 속한 기업이기도 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이러한 인수는 비즈니스 목적(매출)과 기술을 연결하려는 수요에 의해 발생된 것이라고 볼 수 있는데요,
&lt;/p&gt;
&lt;p&gt;
 실제로 회사의 KPI와 Jira 이슈를 연결할 수 있냐는 고객들의 문의가 많이 있다고 합니다.
&lt;/p&gt;
&lt;p&gt;
 아틀라시안은 60명 정도의 별도 팀을 구성하였으며 JiraAlign 이라는 이름으로 제품을 판매할 예정이라고 합니다.
&lt;/p&gt;
&lt;p&gt;
 JiraAlign을 활용하면 회사 목표와 비용 목표 등을 Jira 이슈와 연결하여 확인하고 트래킹, 분석하는데 큰 도움이 될 것 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/71800553/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (신철민 대표님께서 아틀라시안 서밋해서 받아오신 기프트도 무료 나눔 해주셨어요! &amp;gt;_&amp;lt; )
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 아틀라시안 서밋은 단순히 신기술과 제품 업데이트에 대한 내용 뿐만 아니라
&lt;/p&gt;
&lt;p&gt;
 팀과 협업 문화, 건강한 조직, 오픈마인드 등 긍정적인 메시지를 함께 나누는 건설적인 행사로 느껴졌습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 서밋의 주요 세션은 아래 사이트에서 직접 확인하실 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://www.atlassian.com/company/events/summit&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  https://www.atlassian.com/company/events/summit
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 다음 아틀라시안 커뮤니티 이벤트는 5월 15일 개최된다고 하니, 관심 있는 분들의 많은 참여 부탁 드립니다!
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;http://confluence.augkorea.org/pages/viewpage.action?pageId=19630138&quot; rel=&quot;nofollow&quot; style=&quot;text-decoration: none;&quot;&gt;
  AUG Seoul MeetUp #27 2019/05/15(Wed) 19:30 ~ 21:00
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 감사합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Tue, 23 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/04/23/71800553/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/23/71800553/</guid>
        
        <category>atlassian</category>
        
        <category>aug</category>
        
        <category>아틀라시안커뮤니티</category>
        
        <category>아틀라시안유저그룹</category>
        
        <category>summit</category>
        
        
      </item>
    
      <item>
        <title>Kubernetes Volume 을 공부해보자!</title>
        <description>&lt;div class=&quot;conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;markdown&quot;&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  이번 포스팅은 Kubernetes Korea Group의 Kubernetes Architecture Study 모임에서 스터디 후, 발표 진행한 내용입니다.
  &lt;br/&gt;
  Link :
  &lt;a href=&quot;https://github.com/grepsean/k8skr-study-architecture&quot;&gt;
   k8skr-study-architecture Github
  &lt;/a&gt;
 &lt;/p&gt;
 &lt;hr/&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#kubernetes-volume&quot; id=&quot;kubernetes-volume&quot;&gt;
   &lt;strong&gt;
    Kubernetes Volume
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Kubernetes 에서 Volume 으로 사용 가능한 유형은 아래와 같습니다.
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;ul&gt;
   &lt;li&gt;
    emptyDir
   &lt;/li&gt;
   &lt;li&gt;
    hostPath
   &lt;/li&gt;
   &lt;li&gt;
    gitRepo
   &lt;/li&gt;
   &lt;li&gt;
    Openstack Cinder
   &lt;/li&gt;
   &lt;li&gt;
    cephfs
   &lt;/li&gt;
   &lt;li&gt;
    iscsi
   &lt;/li&gt;
   &lt;li&gt;
    rbd
   &lt;/li&gt;
   &lt;li&gt;
    그 외 Public Cloud Storage
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  이처럼 Kubernetes 에서는 다양한 Volume 을 지원합니다.
  &lt;br/&gt;
  책(Kubernetes In Action)에 소개된 emptyDir / hostPath / gitRepo 에 대해 예제와 함께 어떤식으로 사용이 되는지 확인 해보겠습니다.
  &lt;br/&gt;
  추가로 책에는 없는 nfs / cephfs / rbd 를 Kubernetes Volume 으로 사용 해보겠습니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#emptydir&quot; id=&quot;emptydir&quot;&gt;
   &lt;strong&gt;
    emptyDir
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  emptyDir 은 Pod 과 함께 생성되고, 삭제되는 임시 Volume 입니다.
  &lt;br/&gt;
  컨테이너 단위로 관리되는 것이 아니고 Pod 단위로 관리가 되기 때문에 Pod 내 컨테이너가 Error 로 인해 삭제 혹은 재시작이 되더라도 emptyDir 은 삭제가 되지 않고 계속 사용이 가능합니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#emptydir-예제&quot; id=&quot;emptydir-예제&quot;&gt;
   &lt;strong&gt;
    emptyDir 예제
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# cat fortuneloop.sh
#!/bin/bash
trap &quot;exit&quot; SIGINT
mkdir /var/htdocs
while :
do
    echo $(date) Writing fortune to /var/htdocs/index.html
    /usr/games/fortune &amp;gt; /var/htdocs/index.html
    sleep 10
done
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위 스크립트를 이용해서 Docker 이미지를 Build 합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-Dockerfile&quot;&gt;FROM ubuntu:latest
RUN apt-get update ; apt-get -y install fortune
ADD fortuneloop.sh /bin/fortuneloop.sh
ENTRYPOINT /bin/fortuneloop.sh
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Docker Image 를 Build 합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# docker build -t han0495/fortune .
Sending build context to Docker daemon  3.072kB
Step 1/4 : FROM ubuntu:latest
 ---&amp;gt; 94e814e2efa8
Step 2/4 : RUN apt-get update ; apt-get -y install fortune
 ---&amp;gt; Running in 3c8f694a68af

&amp;lt; 중 략 &amp;gt;

Removing intermediate container 3c8f694a68af
 ---&amp;gt; 1e8b262e7bdf
Step 3/4 : ADD fortuneloop.sh /bin/fortuneloop.sh
 ---&amp;gt; 3eee41108b5b
Step 4/4 : ENTRYPOINT /bin/fortuneloop.sh
 ---&amp;gt; Running in 082ee707cdf1
Removing intermediate container 082ee707cdf1
 ---&amp;gt; 58d2d430a7b4
Successfully built 58d2d430a7b4
Successfully tagged han0495/fortune:latest
[root@m01 inside]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  아래와 같은 yaml 파일을 작성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yml&quot;&gt;# cat fortune.yml
apiVersion: v1
kind: Pod
metadata:
  name: fortune
spec:
  containers:
  - image: han0495/fortune
    name: html-generator
    volumeMounts:
    - name: html
      mountPath: /var/htdocs
  - image: nginx:alpine
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/share/nginx/html
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    emptyDir: {}
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  작성한 yaml 파일을 이용하여, Pod을 생성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 fortune]# kubectl get po
NAME                              READY   STATUS    RESTARTS   AGE
fortune                           2/2     Running   0          5m10s
load-generator-557649ddcd-nl6js   1/1     Running   1          6d18h
php-apache-9bd5c887f-nm4h5        1/1     Running   0          6d18h
tomcat-f94554bb9-gkhpz            1/1     Running   0          7d
web-7d77974d4c-gd76n              1/1     Running   0          7d2h
 
[root@m01 fortune]# kubectl describe po fortune
Name:               fortune
Namespace:          default
Priority:           0
PriorityClassName:  &amp;lt;none&amp;gt;
Node:               w03/192.168.13.16
Start Time:         Mon, 08 Apr 2019 17:41:40 +0900
Labels:             &amp;lt;none&amp;gt;
Annotations:        &amp;lt;none&amp;gt;
Status:             Running
IP:                 10.233.89.8
Containers:
  html-generator:
    Container ID:   docker://e25bc8c3b94a2a02edc8b983eb77214a4644a99a3931c1f96f131819060cc676
    Image:          han0495/fortune
    Image ID:       docker-pullable://han0495/fortune@sha256:63d5786a84e67dcd5eec70d516d5788c8e3c3a90d23f23bec1825f7a4526bb00
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Mon, 08 Apr 2019 17:42:01 +0900
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /var/htdocs from html (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-vt6hm (ro)
  web-server:
    Container ID:   docker://ed7c2fd5adbb919fde6ed01d1a80fa74df689d1aa99bc8d883b1b68ed918dd09
    Image:          nginx:alpine
    Image ID:       docker-pullable://nginx@sha256:d5e177fed5e4f264e55b19b84bdc494078a06775612a4f60963f296756ea83aa
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Mon, 08 Apr 2019 17:42:09 +0900
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /usr/share/nginx/html from html (ro)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-vt6hm (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  html:
    Type:    EmptyDir (a temporary directory that shares a pod``s lifetime)
    Medium:
  default-token-vt6hm:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-vt6hm
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  5m26s  default-scheduler  Successfully assigned default/fortune to w03
  Normal  Pulling    5m23s  kubelet, w03       pulling image &quot;han0495/fortune&quot;
  Normal  Pulled     5m5s   kubelet, w03       Successfully pulled image &quot;han0495/fortune&quot;
  Normal  Created    5m5s   kubelet, w03       Created container
  Normal  Started    5m4s   kubelet, w03       Started container
  Normal  Pulling    5m4s   kubelet, w03       pulling image &quot;nginx:alpine&quot;
  Normal  Pulled     4m56s  kubelet, w03       Successfully pulled image &quot;nginx:alpine&quot;
  Normal  Created    4m56s  kubelet, w03       Created container
  Normal  Started    4m56s  kubelet, w03       Started container
[root@m01 fortune]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  실제로 파일이 Docker 이미지에 넣은 스크립트가 동작하는지 확인합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 fortune]# kubectl exec -ti fortune /bin/bash
Defaulting container name to html-generator.
Use 'kubectl describe pod/fortune -n default' to see all of the containers in this pod.
root@fortune:/#
root@fortune:/# cd /var
root@fortune:/var# cd htdocs/
root@fortune:/var/htdocs# ls
index.html
root@fortune:/var/htdocs#
root@fortune:/var/htdocs# cat index.html
You are standing on my toes.
root@fortune:/var/htdocs# while true
&amp;gt; do
&amp;gt; date
&amp;gt; cat index.html
&amp;gt; sleep 10
&amp;gt; done
Mon Apr  8 08:48:43 UTC 2019
Artistic ventures highlighted.  Rob a museum.
Mon Apr  8 08:48:53 UTC 2019
Never reveal your best argument.
Mon Apr  8 08:49:03 UTC 2019
You can create your own opportunities this week.  Blackmail a senior executive.
Mon Apr  8 08:49:13 UTC 2019
You have a strong appeal for members of the opposite sex.
Mon Apr  8 08:49:23 UTC 2019
You will be reincarnated as a toad; and you will be much happier.
^C
root@fortune:/var/htdocs#
&lt;/code&gt;&lt;/pre&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#hostpath&quot; id=&quot;hostpath&quot;&gt;
   &lt;strong&gt;
    hostPath
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  hostPath는 로컬 디스크의 경로를 Pod 에 Mount 해서 사용하는 Volume 방식입니다.
  &lt;br/&gt;
  Docker 에서 -v 옵션으로 Volume 을 연결하는 것과 동일하다고 생각하면 됩니다.
 &lt;/p&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#hostpath-예제&quot; id=&quot;hostpath-예제&quot;&gt;
   &lt;strong&gt;
    hostPath 예제
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# cat hostpath-pod.yml
apiVersion: v1
kind: Pod
metadata:
  name: hostpath
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: volumepath
      mountPath: /usr/share/nginx/html
  volumes:
  - name : volumepath
    hostPath:
      path: /imsi
      type: Directory
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  nginx 의 index Directory 에 /imsi 라는 로컬 디스크 경로를 Mount 합니다.
  &lt;br/&gt;
  이후 Pod 을 해당 yaml 을 이용해서 구동합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 pod-example]# kubectl exec -ti hostpath -- /bin/bash
root@hostpath:/#
root@hostpath:/# ls
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@hostpath:/#
root@hostpath:/# cd /usr
root@hostpath:/usr# cd share/
root@hostpath:/usr/share# cd nginx/
root@hostpath:/usr/share/nginx# cd html/
root@hostpath:/usr/share/nginx/html# ls
root@hostpath:/usr/share/nginx/html#
root@hostpath:/usr/share/nginx/html# touch test
root@hostpath:/usr/share/nginx/html# exit
exit
[root@m01 pod-example]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Pod 이 구동된 Worker의 로컬 디스크 /imsi 경로를 확인해보면 아래와 같이 파일이 생성된 것을 확인 할 수 있습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@w01 ~]# ls -la /imsi
합계 0
drwxrwxrwx   2 root root  18  4월  9 13:15 .
dr-xr-xr-x. 18 root root 256  4월  9 09:45 ..
-rw-r--r--   1 root root   0  4월  9 13:15 test
[root@w01 ~]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#gitrepo&quot; id=&quot;gitrepo&quot;&gt;
   &lt;strong&gt;
    gitRepo
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  gitRepo 는 github에 있는 Repository 에서 Source 를 Clone 하고 해당 Clone 된 데이터를 Pod 의 Volume으로 할당합니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#gitrepo-예제&quot; id=&quot;gitrepo-예제&quot;&gt;
   &lt;strong&gt;
    gitRepo 예제
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# cat git-http.yml
apiVersion: v1
kind: Pod
metadata:
  name: gitrepo-httpd
spec:
  containers:
  - image: httpd
    name: web-server
    volumeMounts:
    - name: html
      mountPath: /usr/local/apache2/htdocs
      readOnly: true
    ports:
    - containerPort: 80
      protocol: TCP
  volumes:
  - name: html
    gitRepo:
      repository: https://github.com/chhanz/docker_training.git
      revision: master
      directory: .
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위와 같이 Github에서 docker_training.git Source를 Clone 합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 tmp]# kubectl describe po gitrepo-httpd
Name:               gitrepo-httpd
Namespace:          default
Priority:           0
PriorityClassName:  &amp;lt;none&amp;gt;
Node:               w02/192.168.13.15
Start Time:         Mon, 08 Apr 2019 21:51:43 +0900
Labels:             &amp;lt;none&amp;gt;
Annotations:        &amp;lt;none&amp;gt;
Status:             Pending
IP:
Containers:
  web-server:
    Container ID:
    Image:          nginx:alpine
    Image ID:
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Waiting
      Reason:       ContainerCreating
    Ready:          False
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /usr/share/nginx/html from html (ro)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-vt6hm (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             False
  ContainersReady   False
  PodScheduled      True
Volumes:
  html:
    Type:        GitRepo (a volume that is pulled from git when the pod is created)
    Repository:  https://github.com/chhanz/docker_training.git
    Revision:    master
  default-token-vt6hm:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-vt6hm
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type     Reason       Age              From               Message
  ----     ------       ----             ----               -------
  Normal   Scheduled    6s               default-scheduler  Successfully assigned default/gitrepo-httpd to w02
  Warning  FailedMount  1s (x4 over 5s)  kubelet, w02       MountVolume.SetUp failed for volume &quot;html&quot; : failed to exec 'git clone -- https://github.com/chhanz/docker_training.git .': : executable file not found in $PATH
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위와 같이 에러가 발생하며, Volume 이 Mount 가 안되었습니다.
  &lt;br/&gt;
  이유는 Pod 이 실행될 Worker 노드에 git 명령어가 없어서 발생된 에러였습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 gitrepo-pv]# kubectl describe po gitrepo-httpd
Name:               gitrepo-httpd
Namespace:          default
Priority:           0
PriorityClassName:  &amp;lt;none&amp;gt;
Node:               w01/192.168.13.14
Start Time:         Mon, 08 Apr 2019 21:58:23 +0900
Labels:             &amp;lt;none&amp;gt;
Annotations:        &amp;lt;none&amp;gt;
Status:             Running
IP:                 10.233.118.8
Containers:
  web-server:
    Container ID:   docker://38158075431bab4e7cfe22e34b615e66ac04e37ad7832a531d811cd67b27962a
    Image:          httpd
    Image ID:       docker-pullable://httpd@sha256:b4096b744d92d1825a36b3ace61ef4caa2ba57d0307b985cace4621139c285f7
    Port:           80/TCP
    Host Port:      0/TCP
    State:          Running
      Started:      Mon, 08 Apr 2019 21:58:49 +0900
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /usr/local/apache2/htdocs from html (ro)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-vt6hm (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  html:
    Type:        GitRepo (a volume that is pulled from git when the pod is created)
    Repository:  https://github.com/chhanz/docker_training.git
    Revision:    master
  default-token-vt6hm:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-vt6hm
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  28s   default-scheduler  Successfully assigned default/gitrepo-httpd to w01
  Normal  Pulling    21s   kubelet, w01       pulling image &quot;httpd&quot;
  Normal  Pulled     0s    kubelet, w01       Successfully pulled image &quot;httpd&quot;
  Normal  Created    0s    kubelet, w01       Created container
  Normal  Started    0s    kubelet, w01       Started container
[root@m01 gitrepo-pv]# kubectl get po
NAME                              READY   STATUS    RESTARTS   AGE
fortune                           2/2     Running   0          4h17m
gitrepo-httpd                     1/1     Running   0          33s
load-generator-557649ddcd-nl6js   1/1     Running   1          6d22h
php-apache-9bd5c887f-nm4h5        1/1     Running   0          6d22h
tomcat-f94554bb9-gkhpz            1/1     Running   0          7d4h
web-7d77974d4c-gd76n              1/1     Running   0          7d6h
[root@m01 gitrepo-pv]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위와 같이 Worker 노드에 git 명령을 설치한 이후, 정상적으로 Volume 이 Mount 되는 것을 확인 할 수 있었습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@w01 /]# find * | grep index.html
 
var/lib/kubelet/pods/fcd69917-59fd-11e9-a751-001a4a160172/volumes/kubernetes.io~git-repo/html/index.html
 
[root@w01 /]# cd var/lib/kubelet/pods/fcd69917-59fd-11e9-a751-001a4a160172/volumes/kubernetes.io~git-repo/html/
[root@w01 html]# ls
copy.html  index.html  README.md  util
[root@w01 html]# ls -la
total 20
drwxrwxrwx 4 root root   82 Apr  8 21:58 .
drwxr-xr-x 3 root root   18 Apr  8 21:58 ..
-rw-r--r-- 1 root root 2070 Apr  8 21:58 copy.html
drwxr-xr-x 8 root root  180 Apr  8 21:58 .git
-rw-r--r-- 1 root root 9594 Apr  8 21:58 index.html
-rw-r--r-- 1 root root  108 Apr  8 21:58 README.md
drwxr-xr-x 2 root root   23 Apr  8 21:58 util
[root@w01 html]#
[root@w01 html]#
[root@w01 html]# cat README.md
# Docker Training ReadMe
Custumer training page
 
 - index.html
 - copy.html     // Copy&amp;amp;Paste
 - putty.exe
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위와 같이 Worker 노드에 해당 git Source 를 Clone 하고 Pod 에 Mount 된 것을 확인 할 수 있었습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;## Master Node
[root@m01 gitrepo-pv]# kubectl delete -f git-http.yml
pod &quot;gitrepo-httpd&quot; deleted
 
## Worker Node
[root@w01 kubernetes.io~git-repo]# cd ..
cd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
[root@w01 ..]# ls
[root@w01 ..]#
[root@w01 ..]# ls -la
total 0
[root@w01 ..]# pwd
/var/lib/kubelet/pods/fcd69917-59fd-11e9-a751-001a4a160172/volumes/kubernetes.io~git-repo/..
[root@w01 ..]#
[root@w01 ..]#
[root@w01 ..]# cd ..
cd: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
[root@w01 ..]# ls
[root@w01 ..]#
[root@w01 ..]# ls -la /var/lib/kubelet/pods/fcd69917-59fd-11e9-a751-001a4a160172/
ls: cannot access /var/lib/kubelet/pods/fcd69917-59fd-11e9-a751-001a4a160172/: No such file or directory
[root@w01 ..]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이처럼 해당 Pod이 삭제되면 Clone 된 Git Source는 삭제가 되는 것을 확인 하였습니다.
  &lt;br/&gt;
  위 테스트를 진행해보니 Git Source 를 Clone 만하고 Github Repository를 계속 Sync하는 것은 아닌 것으로 확인 하였습니다.
 &lt;/p&gt;
 &lt;p&gt;
  지금까지 emptyDir / hostPath / gitRepo 에 대해 예제를 통해 확인 하였습니다.
  &lt;br/&gt;
  nfs / cephfs / rbd 은 다음 포스팅에서 이어서 설명하도록 하겠습니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#network-volume&quot; id=&quot;network-volume&quot;&gt;
   &lt;strong&gt;
    Network Volume
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  이어서 Network Volume 으로 사용될 nfs / cephfs / ceph rbd 를 예제와 함께 알아보도록 하겠습니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#persistent-volume-와-persistent-volume-claim&quot; id=&quot;persistent-volume-와-persistent-volume-claim&quot;&gt;
   &lt;strong&gt;
    Persistent Volume 와 Persistent Volume Claim
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  Persistent Volume 와 Persistent VolumeClaim 가 있는데,
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   &lt;strong&gt;
    Persistent Volume
   &lt;/strong&gt;
   (이하 PV) 는 Kubernetes 에서 관리되는 저장소로 Pod 과는 다른 수명 주기로 관리됩니다.
   &lt;br/&gt;
   Pod 이 재실행 되더라도, PV의 데이터는 정책에 따라
   &lt;strong&gt;
    유지/삭제
   &lt;/strong&gt;
   가 됩니다.
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   &lt;strong&gt;
    Persistent Volume Claim
   &lt;/strong&gt;
   (이하 PVC) 는 PV를 추상화하여 개발자가 손쉽게 PV를 사용 가능하게 만들어주는 기능입니다.
   &lt;br/&gt;
   개발자는 사용에 필요한 Volume의 크기, Volume의 정책을 선택하고 요청만 하면 됩니다.
   &lt;br/&gt;
   운영자는 개발자의 요청에 맞게 PV 를 생성하게 되고, PVC는 해당 PV를 가져가게 됩니다.
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;p&gt;
  &lt;img src=&quot;/assets/images/71798599/0.png&quot;/&gt;
 &lt;/p&gt;
 &lt;p&gt;
  이와 같은 방식을
  &lt;strong&gt;
   Static Provisioning
  &lt;/strong&gt;
  이라 합니다.
  &lt;br/&gt;
  예제를 통해 Static Provisioning을 확인 해보겠습니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#static-provisioning&quot; id=&quot;static-provisioning&quot;&gt;
   &lt;strong&gt;
    Static Provisioning
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#nfs&quot; id=&quot;nfs&quot;&gt;
   &lt;strong&gt;
    NFS
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  NFS 서버를 PV로 사용하는 방식입니다.
  &lt;br/&gt;
  예제에 활용될 yaml 파일 내용은 아래와 같습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# cat nfs-pod.yml
apiVersion: v1
kind: Pod
metadata:
  name: nfs-nginx
spec:
  containers:
  - name: nginx
    image: nginx
    volumeMounts:
    - name: nfsvol
      mountPath: /usr/share/nginx/html
  volumes:
  - name : nfsvol
    nfs:
      path: /data/nfs-ngnix
      server: 192.168.13.10
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위 yaml 파일을 이용해 Pod 을 생성하면
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 pod-example]# kubectl describe po nfs-nginx
Name:               nfs-nginx
Namespace:          default
Priority:           0
PriorityClassName:  &amp;lt;none&amp;gt;
Node:               w03/192.168.13.16
Start Time:         Sun, 14 Apr 2019 13:44:52 +0900
Labels:             &amp;lt;none&amp;gt;
Annotations:        &amp;lt;none&amp;gt;
Status:             Running
IP:                 10.233.89.5
Containers:
  nginx:
    Container ID:   docker://20fa842803535803e1c0c48c204cffe1d464f9f96e3fcf4d7eed11c0bb8aeed0
    Image:          nginx
    Image ID:       docker-pullable://nginx@sha256:50174b19828157e94f8273e3991026dc7854ec7dd2bbb33e7d3bd91f0a4b333d
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sun, 14 Apr 2019 13:45:13 +0900
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /usr/share/nginx/html from nfsvol (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-9vmtn (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  nfsvol:
    Type:      NFS (an NFS mount that lasts the lifetime of a pod)
    Server:    192.168.13.10
    Path:      /data/nfs-ngnix
    ReadOnly:  false
  default-token-9vmtn:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-9vmtn
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  50s   default-scheduler  Successfully assigned default/nfs-nginx to w03
  Normal  Pulling    46s   kubelet, w03       pulling image &quot;nginx&quot;
  Normal  Pulled     28s   kubelet, w03       Successfully pulled image &quot;nginx&quot;
  Normal  Created    28s   kubelet, w03       Created container
  Normal  Started    28s   kubelet, w03       Started container
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  nfs-nginx 라는 Pod 이 생성이 되고 위와 같이
  &lt;strong&gt;
   nfsvol
  &lt;/strong&gt;
  이라는 Volume 이 Attach 된 것을 확인 할 수 있습니다.
  &lt;br/&gt;
  nginx 서비스가 연결된 Volume 을 통해 서비스가 되는지 확인해봅니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 pod-example]# curl 10.233.89.5
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;NFS Index-v1&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
[root@m01 pod-example]#

# Pod 내부에 접근해서 확인
[root@m01 pod-example]# kubectl exec -ti nfs-nginx /bin/bash
root@nfs-nginx:/#
root@nfs-nginx:/# cd /usr/share/nginx/html/
root@nfs-nginx:/usr/share/nginx/html# cat index.html
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;NFS Index-v1&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
root@nfs-nginx:/usr/share/nginx/html#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  &lt;strong&gt;
   NFS Index-v1
  &lt;/strong&gt;
  라는 index.html 을 가지고 있는 Volume 입니다.
  &lt;br/&gt;
  NFS 서버에 직접 접근해서 index.html 파일을 수정해보겠습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@kube-depoly nfs-ngnix]# pwd
/data/nfs-ngnix
[root@kube-depoly nfs-ngnix]# cat index.html
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;NFS Index-v1&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
[root@kube-depoly nfs-ngnix]# vi index.html        // index.html 수정
[root@kube-depoly nfs-ngnix]# cat index.html
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;NFS Index-v2&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
[root@kube-depoly nfs-ngnix]#

# 적용 확인
[root@m01 pod-example]# curl 10.233.89.5
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;NFS Index-v2&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
[root@m01 pod-example]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  이와 같이 Pod 에 NFS 서버가 연결 되어 있는 것을 확인 할 수 있었습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# NFS 로 Volume Attach 되어 있음
root@nfs-nginx:/usr/share/nginx/html# mount | grep nfs
192.168.13.10:/data/nfs-ngnix on /usr/share/nginx/html type nfs4 (rw,relatime,vers=4.1,rsize=262144,wsize=262144,namlen=255,hard,proto=tcp,timeo=600,retrans=2,sec=sys,clientaddr=192.168.13.15,local_lock=none,addr=192.168.13.10)
root@nfs-nginx:/usr/share/nginx/html#
&lt;/code&gt;&lt;/pre&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#cephfs&quot; id=&quot;cephfs&quot;&gt;
   &lt;strong&gt;
    cephfs
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  Software Defined Storage 인 ceph 를 이용하는 방식입니다.
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   Worker 노드에서 cephfs 를 사용하기 위해 ceph-common 패키지를 설치합니다.
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# yum -y install epel-release
# rpm -Uvh https://download.ceph.com/rpm-luminous/el7/noarch/ceph-release-1-0.el7.noarch.rpm
# yum -y install ceph-common
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  cephfs 를 사용하기 위해서는 Key 가 필요로 한데, 아래와 같은 방식으로 Key 값을 수집하고 Kubernete Secret 에 등록합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@s01 ~]# ceph auth get client.admin
exported keyring for client.admin
[client.admin]
    key = AQC6s6Vc83jwKBAAtckE6yz3eTM9lWwK60QNYw==
    caps mds = &quot;allow *&quot;
    caps mgr = &quot;allow *&quot;
    caps mon = &quot;allow *&quot;
    caps osd = &quot;allow *&quot;
[root@s01 ~]#
 
[root@s01 ceph]# ceph-authtool -p ceph.client.admin.keyring
AQC6s6Vc83jwKBAAtckE6yz3eTM9lWwK60QNYw==
[root@s01 ceph]#

# Secret 생성
[root@m01 cephfs]# cat ceph-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ceph-secret
data:
  key: QVFDNnM2VmM4M2p3S0JBQXRja0U2eXozZVRNOWxXd0s2MFFOWXc9PQ==

[root@m01 cephfs]# kubectl create -f ceph-secret.yaml
secret/ceph-secret created

[root@m01 cephfs]# kubectl get secret ceph-secret
NAME          TYPE     DATA   AGE
ceph-secret   Opaque   1      23s
[root@m01 cephfs]# kubectl get secret ceph-secret -o yaml
apiVersion: v1
data:
  key: QVFDNnM2VmM4M2p3S0JBQXRja0U2eXozZVRNOWxXd0s2MFFOWXc9PQ==
kind: Secret
metadata:
  creationTimestamp: &quot;2019-04-14T06:13:44Z&quot;
  name: ceph-secret
  namespace: default
  resourceVersion: &quot;873772&quot;
  selfLink: /api/v1/namespaces/default/secrets/ceph-secret
  uid: 7515ad43-5e7c-11e9-ba95-001a4a160172
type: Opaque
[root@m01 cephfs]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  Pod 에 cephfs Volume 을 연결합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;[root@m01 cephfs]# cat cephfs-with-secret.yaml
apiVersion: v1
kind: Pod
metadata:
  name: cephfs-httpd
spec:
  containers:
  - name: cephfs-httpd
    image: httpd
    volumeMounts:
    - mountPath: /usr/local/apache2/htdocs
      name: cephfs
  volumes:
  - name: cephfs
    cephfs:
      monitors:
      - 192.168.13.6:6789
      - 192.168.13.7:6789
      - 192.168.13.8:6789
      user: admin
      path: /httpd-index
      secretRef:
        name: ceph-secret
      readOnly: false
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  cephfs 의 /httpd-index 경로에는 index.html 이 존재합니다.
  &lt;br/&gt;
  Pod 을 생성합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 cephfs]# kubectl create -f cephfs-with-secret.yaml
pod/cephfs-httpd created
[root@m01 cephfs]# kubectl get po
NAME                              READY   STATUS    RESTARTS   AGE
cephfs-httpd                      1/1     Running   0          24s
load-generator-557649ddcd-jq987   1/1     Running   1          4d20h
php-apache-9bd5c887f-p6lrq        1/1     Running   0          4d20h
[root@m01 cephfs]#
 
[root@m01 cephfs]# kubectl describe po cephfs-httpd
Name:               cephfs-httpd
Namespace:          default
Priority:           0
PriorityClassName:  &amp;lt;none&amp;gt;
Node:               w03/192.168.13.16
Start Time:         Sun, 14 Apr 2019 15:16:48 +0900
Labels:             &amp;lt;none&amp;gt;
Annotations:        &amp;lt;none&amp;gt;
Status:             Running
IP:                 10.233.89.6
Containers:
  cephfs-httpd:
    Container ID:   docker://71e17fb3708a68448fdded4a20c81af63716a1146156dc5a5b4b8145a290f3dc
    Image:          httpd
    Image ID:       docker-pullable://httpd@sha256:b4096b744d92d1825a36b3ace61ef4caa2ba57d0307b985cace4621139c285f7
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sun, 14 Apr 2019 15:17:04 +0900
    Ready:          True
    Restart Count:  0
    Environment:    &amp;lt;none&amp;gt;
    Mounts:
      /usr/local/apache2/htdocs from cephfs (rw)
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-9vmtn (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  cephfs:
    Type:        CephFS (a CephFS mount on the host that shares a pods lifetime)
    Monitors:    [192.168.13.6:6789 192.168.13.7:6789 192.168.13.8:6789]
    Path:        /httpd-index
    User:        admin
    SecretFile:
    SecretRef:   &amp;amp;LocalObjectReference{Name:ceph-secret,}
    ReadOnly:    false
  default-token-9vmtn:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-9vmtn
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  36s   default-scheduler  Successfully assigned default/cephfs-httpd to w03
  Normal  Pulling    33s   kubelet, w03       pulling image &quot;httpd&quot;
  Normal  Pulled     21s   kubelet, w03       Successfully pulled image &quot;httpd&quot;
  Normal  Created    20s   kubelet, w03       Created container
  Normal  Started    20s   kubelet, w03       Started container
[root@m01 cephfs]#

# Pod 테스트
[root@m01 cephfs]# curl 10.233.89.6
cephfs Index - v1
[root@m01 cephfs]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  cephfs는 NFS 와 매우 유사합니다. 그로 인해 NFS와 동일하게 PV에 직접 접근해서 파일 내용을 수정하고, Volume Attach 내용을 확인 할 수 있습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# Mount 확인 - Pod 이 작동중인 Worker 노드
[root@w03 ~]# mount | grep ceph
192.168.13.6:6789,192.168.13.7:6789,192.168.13.8:6789:/httpd-index on /var/lib/kubelet/pods/e2b5c688-5e7c-11e9-ba95-001a4a160172/volumes/kubernetes.io~cephfs/cephfs type ceph (rw,relatime,name=admin,secret=&amp;lt;hidden&amp;gt;,acl,wsize=16777216)
[root@w03 ~]#
[root@w03 ~]# cd /var/lib/kubelet/pods/e2b5c688-5e7c-11e9-ba95-001a4a160172/volumes/kubernetes.io~cephfs/cephfs
[root@w03 cephfs]# ls -la
합계 1
drwxr-xr-x 1 root root  1  4월 14 15:05 .
drwxr-x--- 3 root root 20  4월 14 15:16 ..
-rw-r--r-- 1 root root 18  4월 14 15:05 index.html
[root@w03 cephfs]# cat index.html
cephfs Index - v1
[root@w03 cephfs]#

# Cephfs 에 접근해서 직접 파일 수정
[root@kube-depoly httpd-index]# pwd
/cephfs/httpd-index
[root@kube-depoly httpd-index]# vi index.html
[root@kube-depoly httpd-index]# cat index.html
cephfs Index - v2
[root@kube-depoly httpd-index]#
 
[root@m01 cephfs]# curl 10.233.89.6
cephfs Index - v2
[root@m01 cephfs]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  지금까지 Static Provisioning 관련 해서 확인 해보았습니다.
 &lt;/p&gt;
 &lt;p&gt;
  개발자가 PVC를 통해 시스템 관리자에게 PV를 요구하는 과정을 통해 PV를 할당 받고 사용이 가능한데 이 과정을 자동화를 하게 되면 Dynamic Provisioning 이라고 합니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#dynamic-provisioning&quot; id=&quot;dynamic-provisioning&quot;&gt;
   &lt;strong&gt;
    Dynamic Provisioning
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;h2&gt;
  &lt;a href=&quot;#ceph-rbd&quot; id=&quot;ceph-rbd&quot;&gt;
   &lt;strong&gt;
    ceph rbd
   &lt;/strong&gt;
  &lt;/a&gt;
 &lt;/h2&gt;
 &lt;p&gt;
  Dynamic Provisioning는 PVC를 통해 요청하는 PV대해 동적으로 생성을 해주는 제공 방식을 말합니다.
  &lt;br/&gt;
  개발자는 StorageClass 를 통해 필요한 Storage Type을 지정하여 동적으로 할당을 받을 수 있습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# Secret 생성 - ceph Login을 위한 Key
[root@m01 ceph-rbd]# kubectl create -f ceph-admin-secret.yml
secret/ceph-admin-secret created
[root@m01 ceph-rbd]# kubectl create -f ceph-secret.yml
secret/ceph-secret created
&lt;/code&gt;&lt;/pre&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# StorageClass 생성
[root@m01 ceph-rbd]# cat class.yaml
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: rbd
provisioner: ceph.com/rbd
parameters:
  monitors: 192.168.13.6:6789,192.168.13.7:6789,192.168.13.8:6789
  pool: kube
  adminId: admin
  adminSecretNamespace: kube-system
  adminSecretName: ceph-admin-secret
  userId: kube
  userSecretNamespace: kube-system
  userSecretName: ceph-secret
  imageFormat: &quot;2&quot;
  imageFeatures: layering
[root@m01 ceph-rbd]# kubectl get sc
NAME   PROVISIONER    AGE
rbd    ceph.com/rbd   17h
[root@m01 ceph-rbd]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  StorageClass yaml 파일을 보면
  &lt;strong&gt;
   provisioner: ceph.com/rbd
  &lt;/strong&gt;
  항목이 있습니다.
 &lt;/p&gt;
 &lt;blockquote&gt;
  &lt;p&gt;
   위와 같이 ceph rbd 를 제공해줄 provisioner 가 필요합니다.
   &lt;br/&gt;
   provisioner 상세 배포 방식은
   &lt;a href=&quot;https://github.com/kubernetes-incubator/external-storage/blob/master/ceph/rbd/deploy/README.md&quot;&gt;
    ceph-rbd-depoly
   &lt;/a&gt;
   문서를 참조합니다.
  &lt;/p&gt;
 &lt;/blockquote&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# Pod 
[root@m01 ceph-rbd]# kubectl get po -n kube-system | grep rbd
rbd-provisioner-67b4857bcd-7ctlz           1/1     Running   0          17h

# Pod 상세 내역
[root@m01 ceph-rbd]# kubectl describe po rbd-provisioner-67b4857bcd-7ctlz -n kube-system
Name:               rbd-provisioner-67b4857bcd-7ctlz
Namespace:          kube-system
Priority:           0
PriorityClassName:  &amp;lt;none&amp;gt;
Node:               w02/192.168.13.15
Start Time:         Sun, 14 Apr 2019 21:13:49 +0900
Labels:             app=rbd-provisioner
                    pod-template-hash=67b4857bcd
Annotations:        &amp;lt;none&amp;gt;
Status:             Running
IP:                 10.233.96.9
Controlled By:      ReplicaSet/rbd-provisioner-67b4857bcd
Containers:
  rbd-provisioner:
    Container ID:   docker://8f25dca0c870685dc0140294787124e288793243ed6120921d278c701b6c7039
    Image:          quay.io/external_storage/rbd-provisioner:latest
    Image ID:       docker-pullable://quay.io/external_storage/rbd-provisioner@sha256:94fd36b8625141b62ff1addfa914d45f7b39619e55891bad0294263ecd2ce09a
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Sun, 14 Apr 2019 21:13:54 +0900
    Ready:          True
    Restart Count:  0
    Environment:
      PROVISIONER_NAME:  ceph.com/rbd
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from rbd-provisioner-token-79f4c (ro)
Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
Volumes:
  rbd-provisioner-token-79f4c:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  rbd-provisioner-token-79f4c
    Optional:    false
QoS Class:       BestEffort
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:          &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  PVC 를 통해 rbd PV를 요청합니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# cat claim.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: rbd-pvc
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: rbd
  resources:
    requests:
      storage: 2Gi 
&lt;/code&gt;&lt;/pre&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# PVC 생성
[root@m01 ceph-rbd]# kubectl create -f claim.yaml
persistentvolumeclaim/rbd-pvc created

# PVC 확인
[root@m01 ceph-rbd]# kubectl get pvc
NAME            STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
claim1          Bound    pvc-fe9d8199-5eae-11e9-ba95-001a4a160172   1Gi        RWO            rbd            17h
nginx-vol-pvc   Bound    nginx-pv                                   3Gi        RWX                           17h
rbd-pvc         Bound    pvc-5b571f95-5f43-11e9-ba95-001a4a160172   2Gi        RWO            rbd            3s

# PV 연결 확인
[root@m01 ceph-rbd]# kubectl get pv
NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                   STORAGECLASS   REASON   AGE
nginx-pv                                   3Gi        RWX            Retain           Bound    default/nginx-vol-pvc                           17h
pvc-5b571f95-5f43-11e9-ba95-001a4a160172   2Gi        RWO            Delete           Bound    default/rbd-pvc         rbd                     5s
pvc-fe9d8199-5eae-11e9-ba95-001a4a160172   1Gi        RWO            Delete           Bound    default/claim1          rbd                     17h
[root@m01 ceph-rbd]#
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  위와 같이 PVC 를 요청하자 바로 PV가 ceph rbd 형식으로 생성이 되고 Attach 된 것을 확인 할 수 있었습니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;[root@m01 ceph-rbd]# kubectl logs -f rbd-provisioner-67b4857bcd-7ctlz -n kube-system
I0414 12:13:54.944458       1 main.go:85] Creating RBD provisioner ceph.com/rbd with identity: ceph.com/rbd
I0414 12:13:54.949989       1 leaderelection.go:185] attempting to acquire leader lease  kube-system/ceph.com-rbd...
I0414 12:13:55.001529       1 leaderelection.go:194] successfully acquired lease kube-system/ceph.com-rbd
I0414 12:13:55.001754       1 event.go:221] Event(v1.ObjectReference{Kind:&quot;Endpoints&quot;, Namespace:&quot;kube-system&quot;, Name:&quot;ceph.com-rbd&quot;, UID:&quot;c5bb0c91-5eae-11e9-b387-001a4a160174&quot;, APIVersion:&quot;v1&quot;, ResourceVersion:&quot;919145&quot;, FieldPath:&quot;&quot;}): type: 'Normal' reason: 'LeaderElection' rbd-provisioner-67b4857bcd-7ctlz_c5ecdcd7-5eae-11e9-a9ca-6e9439dbce0f became leader
I0414 12:13:55.001901       1 controller.go:631] Starting provisioner controller ceph.com/rbd_rbd-provisioner-67b4857bcd-7ctlz_c5ecdcd7-5eae-11e9-a9ca-6e9439dbce0f!
I0414 12:13:55.102448       1 controller.go:680] Started provisioner controller ceph.com/rbd_rbd-provisioner-67b4857bcd-7ctlz_c5ecdcd7-5eae-11e9-a9ca-6e9439dbce0f!
I0414 12:15:33.439001       1 controller.go:987] provision &quot;default/claim1&quot; class &quot;rbd&quot;: started
I0414 12:15:33.455112       1 event.go:221] Event(v1.ObjectReference{Kind:&quot;PersistentVolumeClaim&quot;, Namespace:&quot;default&quot;, Name:&quot;claim1&quot;, UID:&quot;fe9d8199-5eae-11e9-ba95-001a4a160172&quot;, APIVersion:&quot;v1&quot;, ResourceVersion:&quot;919428&quot;, FieldPath:&quot;&quot;}): type: 'Normal' reason: 'Provisioning' External provisioner is provisioning volume for claim &quot;default/claim1&quot;
I0414 12:15:35.895596       1 provision.go:132] successfully created rbd image &quot;kubernetes-dynamic-pvc-00ab7b91-5eaf-11e9-a9ca-6e9439dbce0f&quot;
I0414 12:15:35.895798       1 controller.go:1087] provision &quot;default/claim1&quot; class &quot;rbd&quot;: volume &quot;pvc-fe9d8199-5eae-11e9-ba95-001a4a160172&quot; provisioned
I0414 12:15:35.895924       1 controller.go:1101] provision &quot;default/claim1&quot; class &quot;rbd&quot;: trying to save persistentvvolume &quot;pvc-fe9d8199-5eae-11e9-ba95-001a4a160172&quot;
I0414 12:15:35.934205       1 controller.go:1108] provision &quot;default/claim1&quot; class &quot;rbd&quot;: persistentvolume &quot;pvc-fe9d8199-5eae-11e9-ba95-001a4a160172&quot; saved
I0414 12:15:35.934420       1 controller.go:1149] provision &quot;default/claim1&quot; class &quot;rbd&quot;: succeeded
I0414 12:15:35.935026       1 event.go:221] Event(v1.ObjectReference{Kind:&quot;PersistentVolumeClaim&quot;, Namespace:&quot;default&quot;, Name:&quot;claim1&quot;, UID:&quot;fe9d8199-5eae-11e9-ba95-001a4a160172&quot;, APIVersion:&quot;v1&quot;, ResourceVersion:&quot;919428&quot;, FieldPath:&quot;&quot;}): type: 'Normal' reason: 'ProvisioningSucceeded' Successfully provisioned volume pvc-fe9d8199-5eae-11e9-ba95-001a4a160172
I0415 05:57:32.016818       1 controller.go:987] provision &quot;default/rbd-pvc&quot; class &quot;rbd&quot;: started
I0415 05:57:32.037901       1 event.go:221] Event(v1.ObjectReference{Kind:&quot;PersistentVolumeClaim&quot;, Namespace:&quot;default&quot;, Name:&quot;rbd-pvc&quot;, UID:&quot;5b571f95-5f43-11e9-ba95-001a4a160172&quot;, APIVersion:&quot;v1&quot;, ResourceVersion:&quot;1081791&quot;, FieldPath:&quot;&quot;}): type: 'Normal' reason: 'Provisioning' External provisioner is provisioning volume for claim &quot;default/rbd-pvc&quot;
I0415 05:57:33.772819       1 provision.go:132] successfully created rbd image &quot;kubernetes-dynamic-pvc-5be57bb6-5f43-11e9-a9ca-6e9439dbce0f&quot;
I0415 05:57:33.773007       1 controller.go:1087] provision &quot;default/rbd-pvc&quot; class &quot;rbd&quot;: volume &quot;pvc-5b571f95-5f43-11e9-ba95-001a4a160172&quot; provisioned
I0415 05:57:33.773112       1 controller.go:1101] provision &quot;default/rbd-pvc&quot; class &quot;rbd&quot;: trying to save persistentvvolume &quot;pvc-5b571f95-5f43-11e9-ba95-001a4a160172&quot;
I0415 05:57:33.793499       1 controller.go:1108] provision &quot;default/rbd-pvc&quot; class &quot;rbd&quot;: persistentvolume &quot;pvc-5b571f95-5f43-11e9-ba95-001a4a160172&quot; saved
I0415 05:57:33.793633       1 controller.go:1149] provision &quot;default/rbd-pvc&quot; class &quot;rbd&quot;: succeeded
I0415 05:57:33.793801       1 controller.go:987] provision &quot;default/rbd-pvc&quot; class &quot;rbd&quot;: started
I0415 05:57:33.794971       1 event.go:221] Event(v1.ObjectReference{Kind:&quot;PersistentVolumeClaim&quot;, Namespace:&quot;default&quot;, Name:&quot;rbd-pvc&quot;, UID:&quot;5b571f95-5f43-11e9-ba95-001a4a160172&quot;, APIVersion:&quot;v1&quot;, ResourceVersion:&quot;1081791&quot;, FieldPath:&quot;&quot;}): type: 'Normal' reason: 'ProvisioningSucceeded' Successfully provisioned volume pvc-5b571f95-5f43-11e9-ba95-001a4a160172
I0415 05:57:33.826515       1 controller.go:996] provision &quot;default/rbd-pvc&quot; class &quot;rbd&quot;: persistentvolume &quot;pvc-5b571f95-5f43-11e9-ba95-001a4a160172&quot; already exists, skipping
&lt;/code&gt;&lt;/pre&gt;
 &lt;ul&gt;
  &lt;li&gt;
   참조: rbd-provisioner docker log
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  Pod 에 PVC를 yaml 추가하여 Pod 생성 할때, PV를 요청하고 StorageClass 를 이용해서 동적으로 Volume을 할당 받았습니다.
  &lt;br/&gt;
  아래는 Pod 에 PVC를 추가한 yaml 구문 Template 입니다.
 &lt;/p&gt;
 &lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# cat test-pod.yaml
kind: Pod
apiVersion: v1
metadata:
  name: test-pod
spec:
  containers:
  - name: test-pod
    image: gcr.io/google_containers/busybox:1.24
    command:
    - &quot;/bin/sh&quot;
    args:
    - &quot;-c&quot;
    - &quot;touch /mnt/SUCCESS &amp;amp;&amp;amp; exit 0 || exit 1&quot;
    volumeMounts:
    - name: pvc
      mountPath: &quot;/mnt&quot;
  restartPolicy: &quot;Never&quot;
  volumes:
  - name: pvc
    persistentVolumeClaim:
      claimName: claim1
&lt;/code&gt;&lt;/pre&gt;
 &lt;p&gt;
  지금까지 포스팅에서 소개된 Volume 은 Kubernetes 에서 제공되는 일부 입니다.
  &lt;br/&gt;
  다양한 Volume 을 제공하고 있으며, 상세 내용은 첨부된 문서 참고하시고 운영하시는 환경에 맞게 사용하면 됩니다.
  &lt;br/&gt;
  감사합니다.
 &lt;/p&gt;
 &lt;h1&gt;
  &lt;a href=&quot;#참고-문서&quot; id=&quot;참고-문서&quot;&gt;
   참고 문서
  &lt;/a&gt;
 &lt;/h1&gt;
 &lt;hr/&gt;
 &lt;p&gt;
  &lt;strong&gt;
   - ceph rbd 관련
  &lt;/strong&gt;
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/kubernetes-incubator/external-storage/tree/master/ceph/rbd&quot;&gt;
    RBD Volume Provisioner for Kubernetes 1.5+
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/kubernetes-incubator/external-storage/blob/master/ceph/rbd/deploy/README.md&quot;&gt;
    RBD Volume Provisioner On Kubernetes Depolyment
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://docs.openshift.com/container-platform/3.5/install_config/storage_examples/ceph_example.html&quot;&gt;
    Example Ceph rbd
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  &lt;strong&gt;
   - Kubernetes 문서
  &lt;/strong&gt;
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/persistent-volumes/&quot;&gt;
    PV 관련
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes&quot;&gt;
    Types of Volumes
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/persistent-volumes/#access-modes&quot;&gt;
    PV Access Mode 관련
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/persistent-volumes/#reclaim-policy&quot;&gt;
    PV Reclaim Policy
   &lt;/a&gt;
  &lt;/li&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-persistent-volume-storage/&quot;&gt;
    Example PVC
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;p&gt;
  &lt;strong&gt;
   - Example yaml
  &lt;/strong&gt;
 &lt;/p&gt;
 &lt;ul&gt;
  &lt;li&gt;
   &lt;a href=&quot;https://github.com/chhanz/k8s-study-example&quot;&gt;
    chhanz Github
   &lt;/a&gt;
  &lt;/li&gt;
 &lt;/ul&gt;
 &lt;script&gt;
  //&lt;![CDATA[

AJS.$('[data-macro-name=&quot;markdown&quot;] code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

//]]&gt;
 &lt;/script&gt;
 &lt;style&gt;
  .hljs {display: inline;}
pre &gt; code {display: block !important;}
 &lt;/style&gt;
 &lt;script&gt;
  //&lt;![CDATA[
 AJS.$('[data-macro-name=&quot;markdown&quot;] table thead th').each(function(i, block) {
    block.classList.add(&quot;confluenceTh&quot;);
});

AJS.$('[data-macro-name=&quot;markdown&quot;] table tbody tr td').each(function(i, block) {
    block.classList.add(&quot;confluenceTd&quot;);
});
//]]&gt;
 &lt;/script&gt;
&lt;/div&gt;</description>
        <pubDate>Mon, 15 Apr 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/04/15/71798599/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/15/71798599/</guid>
        
        
      </item>
    
      <item>
        <title>Atlassian CI/CD Step By Step</title>
        <description>&lt;p&gt;
 안녕하세요.
&lt;/p&gt;
&lt;p&gt;
 오픈소스컨설팅
&lt;/p&gt;
&lt;p&gt;
 아틀라시안팀
&lt;/p&gt;
&lt;p&gt;
 김세연입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 요즘 많은 고객사, 필드에서는 Agile, ALM, DevOps 문화 구축 후 CI/CD를 구축하고 준비하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 CI/CD Step by step을 소개 하겠습니다.
&lt;/p&gt;
&lt;blockquote&gt;
 &lt;p&gt;
  CI/CD란?
 &lt;/p&gt;
 &lt;p&gt;
  CI(Continuous Integration) 지속적인 통합을 의미합니다.
 &lt;/p&gt;
 &lt;p&gt;
  훌륭한 개발A팀 기능 100개와 개발B팀 기능 100개가 통합 된단다고 상상해보세요.
 &lt;/p&gt;
 &lt;p&gt;
  좋은 기능 200개가 될까요?
 &lt;/p&gt;
 &lt;p&gt;
  S/W 통합은 눈에 보이지 않는 복잡한 일입니다.
 &lt;/p&gt;
 &lt;p&gt;
  자동화된 도구로 자주 Build, Test로 S/W의 높은 품질을 유지해야 합니다.
 &lt;/p&gt;
 &lt;p&gt;
  CD(Continuous Delivery or Continuous Deploy)란?
 &lt;/p&gt;
 &lt;p&gt;
  높은 품질의 S/W를 개발서버, 운영서버에 배포하는 과정을 사람 손으로 한다면
 &lt;/p&gt;
 &lt;p&gt;
  시간, 비용, 실수가 발생합니다. Java Legacy System을 운영하는 조직 중에는
 &lt;/p&gt;
 &lt;p&gt;
  빌드 결과 class파일만 교체하는 경우도 있습니다. (신규 개발인데 이렇게 하고 계신가요? 저희한테 빨리 연락주세요)
 &lt;/p&gt;
 &lt;p&gt;
  엑셀 파일에 class파일 리스트 받고..
 &lt;/p&gt;
 &lt;p&gt;
  자동화된 배포 시스템은 시간, 비용, 실수를 방지하고 팀이 더 빠르게 개발, 빌드, 배포를 할 수 있게 해줍니다.
 &lt;/p&gt;
 &lt;p&gt;
  비즈니스팀, 기획, 디자인, 개발, 운영팀은 자동화된 빌드, 배포 시스템으로 민첩함을 유지하고
 &lt;/p&gt;
 &lt;p&gt;
  서비스를 시장에 높은 품질의 소프트웨어를 출시할 수 있습니다.
 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
 저희는 Atlassian 제품으로 요구사항 접수부터 이슈 트래킹, 문서 협업, 저장소, 빌드/배포 모든걸 구현하는 방법을 소개합니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian은 전세계에서 유일하게 ALM, DevOps, Agile을 구현할 수 있는 모든 솔루션이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Atlassian 제품으로 사용했을 때 장점은 관리의 편리성(UI가 비슷합니다.)과 각 부서별 동일한 솔루션 사용으로 소통비용 감소입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/0.jpeg&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &amp;lt;그림. CI/CD 구성도&amp;gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 오늘은 Jira Service Desk 부터 Bamboo 까지 Step by step으로 진행해 보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 하지만 스텝에 정답은 없습니다. 우리 조직에서 '이렇게 하면 좋겠다'를 적용, 프랙티스, 점진적 발전 모델이 좋은 사례가 될거에요.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/1.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &amp;lt;그림. 소프트웨어의 관리는 생명체와 같아서 끊임없는 관리가 필요합니다.&amp;gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-Actor&quot;&gt;
 Actor
&lt;/h1&gt;
&lt;p&gt;
 Actor를 설정해서 이해관계도 같이 설명해 보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  내부 또는 외부 고객, 현업
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 불편함, 문제를 갖고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  Product Owner, Project Leader
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 프로젝트 전체 일정, 계획, 성과등을 관리합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;br/&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/4.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  개발팀
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 문제를 해결하거나 새로운 무언가를 일정에 맞춰 개발합니다.
&lt;/p&gt;
&lt;p&gt;
 일정, 사람은 정해졌으니 해야 할 일을 효율적으로 운영하기 위해서 애자일 방법론을 사용하곤 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;br/&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/5.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  보안, 운영팀
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 서비스, 인프라, 보안 등 어제도 문제가 없었고, 오늘도 문제가 없고, 내일도 문제가 없도록 운영하는 운영팀 입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;br/&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 고객, PO(Product Owner), Dev, Test, Ops, 보안팀 역할을 설정했습니다.
&lt;/p&gt;
&lt;p&gt;
 IT서비스를 기획, 개발, 운영하는데 필요한 팀간의 사일로를 방지하고 현업하는지 알아보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-요구사항접수,서비스기획&quot;&gt;
 요구사항 접수, 서비스 기획
&lt;/h1&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/6.png&quot;/&gt;
 &lt;/span&gt;
 고객께서는 Jira Service Desk 또는 Jira Software로 요구사항을 요청할 수 있습니다.
&lt;/p&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-방법1.JiraServiceDesk&quot;&gt;
 &lt;strong&gt;
  방법1. Jira Service Desk
 &lt;/strong&gt;
&lt;/h2&gt;
&lt;p&gt;
 Jira Service Desk는 친숙하고 쉬운 UI를 제공합니다. 외부, 내부 고객에게 제공하여 쉽게 요구사항 접수를 받을 수 있고
&lt;/p&gt;
&lt;p&gt;
 Confluence Space와 연결하여 유사 문제, 해결 방법 Page를 제공합니다. 문제 해결이 매우 빨라질 수 있습니다!
&lt;/p&gt;
&lt;p&gt;
 SLA(
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  S
 &lt;/span&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  ervice-
 &lt;/span&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  L
 &lt;/span&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  evel
 &lt;/span&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  A
 &lt;/span&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  greement) 측정할 수 있는 항목도 있습니다. 자세한 사항은 SlideShare에 공유했습니다.
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.slideshare.net/ssuser64f754/jira-service-desk-opensourceconsulting-127446252?qid=e0a39608-49d3-4a4f-8b52-6f1a80fc3f46&amp;amp;v=&amp;amp;b=&amp;amp;from_search=2&quot; rel=&quot;nofollow&quot;&gt;
   (여기)
  &lt;/a&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(55,58,60);&quot;&gt;
  큰 특징은 고객은 라이선스가 필요 없습니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;http://at.osci.kr&quot; rel=&quot;nofollow&quot;&gt;
   http://at.osci.kr
  &lt;/a&gt;
  (저희도 서비스 데스크 운영 중입니다. ^^ )
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/7.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &amp;lt;그림. 서비스 데스크 포탈&amp;gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/8.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &amp;lt;그림. 검색어를 입력하면 관련 Confluence Page를 보여줍니다.&amp;gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Jira Service Desk는 고객의 요청사항을 접수하는 포탈이 제공됩니다.
 &lt;/li&gt;
 &lt;li&gt;
  프로젝트별 포탈이 생성됩니다. 서비스 별로 프로젝트를 생성하고 포탈을 제공할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;AtlassianCI/CDStepByStep-방법1.요구사항접수&quot;&gt;
 방법1. 요구사항 접수
&lt;/h3&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/9.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &amp;lt;그림. 요구사항을 접수하는 화면&amp;gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  이슈(티켓) 유형을 선택하여 요청사항을 접수합니다.
 &lt;/li&gt;
 &lt;li&gt;
  입력하는 항목은 Jira Service Desk Admin께서 설정할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  Summary를 입력할 때 관련 Confluence 문서를 제공합니다.
 &lt;/li&gt;
 &lt;li&gt;
  서비스 팀은 반복적으로 동일하게 일어나는 문제 해결을 Confluence page(지식 베이스)로 제공함으로써
 &lt;/li&gt;
 &lt;li&gt;
  고객이 문제 해결을 더욱 빨리 도와줍니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/10.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &amp;lt;그림. 요구사항 접수 - 티켓 생성 &amp;gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  생성된 이슈(티켓) 상태를 포탈에서 확인할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/11.png&quot;/&gt;
 &lt;/span&gt;
 Product Owner또는 Project Leader는 서비스 데스크에 접수된 이슈를 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/12.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  서비스 데스크에서 해결하지 못하는 문제는 개발팀에게 요청할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  Jira Service Desk에서 Jira Software Issue를 연결할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/13.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림. 서비스 데스크 프로젝트에서 개발팀 프로젝트 이슈 연결&amp;gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/14.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림. 서비스 데스크 이슈와 Jira Software 이슈 연결&amp;gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  서비스 데스크로 접수된 요청사항은 고객의 언어로 이야기를 합니다.
 &lt;/li&gt;
 &lt;li&gt;
  하지만 개발팀은 개발언어, 엔지니어의 언어로 이야기합니다.
 &lt;/li&gt;
 &lt;li&gt;
  서비스 데스크는 중간에서 협업을 돕고 사일로를 방지합니다.
 &lt;/li&gt;
 &lt;li&gt;
  개발팀은 개발에 전념할 수 있겠죠?
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;AtlassianCI/CDStepByStep-방법2.JiraSoftware&quot;&gt;
 방법2. Jira Software
&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Jira Software에서 바로 요구사항 접수를 할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  하지만 고객도 Jira Software를 사용하기 때문에 라이선스가 필요합니다.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/15.png&quot;/&gt;
  &lt;/span&gt;
  나도 라이선스 필요하다해~
 &lt;/li&gt;
 &lt;li&gt;
  IT부서가 아닌 고객은 Jira Software UI가 어렵고 낯설게 느껴질 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  우리는 서비스를 자체적으로 기획하고 만드는 팀이라면
 &lt;/li&gt;
 &lt;li&gt;
  Jira Software로도 충분합니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/16.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림. 이슈를 만들고 시작하세요&amp;gt;
&lt;/p&gt;
&lt;h3 id=&quot;AtlassianCI/CDStepByStep-일하는방법Scrum,Kanban&quot;&gt;
 일하는 방법 Scrum, Kanban
&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Jira Software는 Scrum board와 Kanban board를 생성할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  Agile 방법으로 일을 진행할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;strong&gt;
   &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
    &lt;img src=&quot;/assets/images/63373558/17.png&quot;/&gt;
   &lt;/span&gt;
  &lt;/strong&gt;
 &lt;/li&gt;
 &lt;li&gt;
  개발팀은 이슈를 담당자에게 할당하고, 논의하고 산출물은 Confluence에 작성을 합니다.
 &lt;/li&gt;
 &lt;li&gt;
  팀에서 정한 Workflow에 따라서 이슈는 흘러가게 됩니다.
  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
   &lt;li&gt;
    예) 할일-기획-개발-테스트-배포신청-배포완료
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
 &lt;li&gt;
  이슈 오너쉽에 대해서 많이 궁금해 하시는데요 Kanban의 이슈 오너쉽을 예시로 들어보겠습니다.
  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
   &lt;li&gt;
    예)
    &lt;ul style=&quot;list-style-type: square;&quot;&gt;
     &lt;li&gt;
      팀은 비즈니스팀, 개발팀, 운영팀이 있습니다.
     &lt;/li&gt;
     &lt;li&gt;
      할일-기획-개발-테스트-배포신청-배포완료 Workflow 입니다.
     &lt;/li&gt;
     &lt;li&gt;
      비즈니스팀에서는 할일, 기획 상태를 소유하고
     &lt;/li&gt;
     &lt;li&gt;
      개발팀에서는 개발-테스트 상태를 소유하고
     &lt;/li&gt;
     &lt;li&gt;
      운영팀에서는 배포신청-배포완료 상태를 소요할 수 있습니다.
     &lt;/li&gt;
     &lt;li&gt;
      각 상태의 중요도 설정은 오너쉽이 있는 팀에서 합니다.
     &lt;/li&gt;
     &lt;li&gt;
      비즈니스팀은 기획 이슈의 중요도를 자유롭게 정할 수 있습니다.
     &lt;/li&gt;
     &lt;li&gt;
      비즈니스팀의 상태의 이슈를 개발팀에서 선택하여 개발로 옮긴 후부터 개발팀의 소유가 됩니다.
     &lt;/li&gt;
    &lt;/ul&gt;
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;AtlassianCI/CDStepByStep-JiraWrapup&quot;&gt;
 Jira Wrap up
&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Jira ServiceDesk, Jira Software 로 요구사항을 요청할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  대외 서비스를 하거나 고객이 많다면 Jira ServiceDesk로 고객을 관리할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  고객에 내부에 있거나 Jira Software를 같이 사용한다면 Jira Software로 충분합니다.
 &lt;/li&gt;
 &lt;li&gt;
  이슈(티켓, 일감)를 만드는 이유는 이슈 진행 상황을 공유하고 협업과 사일로 현상을 방지할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  이슈는 시작과 끝이 있습니다. 그래서 설명에 산출물, 많은 정보는 Confluence에 남겨야 합니다.
 &lt;/li&gt;
 &lt;li&gt;
  설명에 포함된 단어는 검색이 어렵고 이슈가 해결 됐을 때 찾기 어렵기 때문입니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;AtlassianCI/CDStepByStep-JiraServiceDeskCaseStudy&quot;&gt;
 Jira Service Desk Case Study
&lt;/h3&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Kakao
  &lt;ul style=&quot;list-style-type: square;&quot;&gt;
   &lt;li&gt;
    Jira Service Desk로 프로젝트 생성 요청을 받습니다.
   &lt;/li&gt;
   &lt;li&gt;
    프로젝트 타입, 사용 스킴정보로 프로젝트를 생성합니다.
   &lt;/li&gt;
   &lt;li&gt;
    프로젝트 생성은 자동화 기능을 직접 개발하셨습니다.
   &lt;/li&gt;
   &lt;li&gt;
    내부 사용자들의 다양한 불편 사항을 서비스 데스크로 접수를 받습니다.
   &lt;/li&gt;
   &lt;li&gt;
    평균 응답 시간은 30분이고 SLA 100%를 준수하고 있습니다.
   &lt;/li&gt;
   &lt;li&gt;
    Confluence Page를 연결하여 문제 해결을 빠르게 하고 있습니다.
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-팀협업-지식베이스구축&quot;&gt;
 팀 협업 - 지식 베이스 구축
&lt;/h1&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/18.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  좋은 생각, 아이디어는 어디에 있을까요?
  &lt;br/&gt;
  우리 머릿속에 있습니다. 그 좋은 것들을 정리한 파일은 어디에 있을까요? 내 컴퓨터 또는 파일 서버에 있습니다.
  &lt;br/&gt;
  이러한 문제점을 해결하기 위해서 쉐어포인트, 구글닥스 등 문서 협업 도구를 사용하지만 이슈(work)와 연결하기는 쉽지 않습니다.
  &lt;br/&gt;
  Confluence는 Jira와 강력한 통합을 지원하면서 언제 어디서나 팀과 협업할 수 있습니다.
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/19.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림. Confluence 구조&amp;gt;
&lt;/p&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-Page생성&quot;&gt;
 Page 생성
&lt;/h2&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/20.png&quot;/&gt;
 &lt;/span&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/21.png&quot;/&gt;
 &lt;/span&gt;
 &lt;strong style=&quot;letter-spacing: 0.0px;&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/22.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/strong&gt;
 &lt;strong style=&quot;letter-spacing: 0.0px;&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/23.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/strong&gt;
 &lt;strong style=&quot;letter-spacing: 0.0px;&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/24.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  모든 사용자는 Page를 만들고 공유할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  (방법1) 최초의 요청사항을 Confluence로 시작해서 Jira로 시작할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  (방법2) 최초의 요청사항을 Jira로 시작해서 Confluence에 작성할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  둘 중 더 좋은 방법은 무엇일까요? 정답은 실무자가 알고 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  프로세스가 흘러가는데 편하고 어색하지 않는 방법을 추천 드립니다. (감이 안오시면 다 해보는 걸로..)
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/25.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림. 저도 Confluence에서 글을 작성하고 있어요&amp;gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Create 버튼으로 Blank Page를 생성하거나
 &lt;/li&gt;
 &lt;li&gt;
  Atlassian에서 제공하는 Template으로 Page를 생성할 수 있어요.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/26.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;그림. Atlassian에서 제공하는 Template&amp;gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Template도 만들어서 정형화된 문서를 찍어낼 수 있어요.
 &lt;/li&gt;
 &lt;li&gt;
  양식을 고민하지 말고 GO
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-JiraIssue연결&quot;&gt;
 Jira Issue 연결
&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Confluence Page에서 Jira 이슈를 연결할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/27.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  반대로 Jira issue에서 Confluence Page를 연결할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/28.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Issue(work)은 일정, 진행 상태, 이해관계자 알림 등이 목적입니다.
 &lt;/li&gt;
 &lt;li&gt;
  Page는 일이 진행되면 필요한 지식이 쌓이는 곳입니다.
 &lt;/li&gt;
 &lt;li&gt;
  목적에 맞게 일, 지식이 저장되고 사일로 현상을 방지하며 필요할 때 또 꺼내서 보기 쉽습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-JiraIssueChart&quot;&gt;
 Jira Issue Chart
&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Confluence에서는 Jira이슈 검색으로 차트로 표시할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/29.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-Notification&quot;&gt;
 Notification
&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Confluence Notification은 신문 구독과 같습니다.
 &lt;/li&gt;
 &lt;li&gt;
  보고싶은 내용을 개인 설정으로 받을 수 있어요.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/30.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/li&gt;
 &lt;li&gt;
  쉬운 정보 공유와 협업을 촉진 시키는데 이메일 알람이 큰 역할을 합니다.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/31.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/li&gt;
 &lt;li&gt;
  그 중 일간 업데이트 구독은 24시간 동안 변경 사항을 간단하게 정리해서 메일로 보내줍니다.
 &lt;/li&gt;
 &lt;li&gt;
  물론 공간, 페이지 권한이 있는 사용자들만 볼 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-ConfluenceWrapup&quot;&gt;
 Confluence Wrap up
&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Jira Issue(work)과 산출물을 연결하세요.
 &lt;/li&gt;
 &lt;li&gt;
  Confluence는 최신 정보를 팀과 실시간으로 공유하고 발전 시킵니다.
 &lt;/li&gt;
 &lt;li&gt;
  Jira Comment, Description에는 지식을 남기 마세요. 이슈가 릴리즈 되거나 완료되면 이슈 Comment 찾기 힘들어요.
 &lt;/li&gt;
 &lt;li&gt;
  Confluence ↔ Jira Service Desk 연결로 문제 해결을 최전방에서 해결할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;strong&gt;
   내 머릿속, 내 컴퓨터에 지식을 가두지 말고 Confluence에 남기세요.
  &lt;/strong&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-Bitbucket-프로페셔널팀을위한Git솔루션&quot;&gt;
 Bitbucket - 프로페셔널 팀을 위한 Git 솔루션
&lt;/h1&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-JiraIssue-Branch연결&quot;&gt;
 Jira Issue - Branch 연결
&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Jira Software와 Bitbucket의 통합으로 Branch 생성을 Jira에서 할 수 있습니다.
  &lt;br/&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/32.png&quot;/&gt;
  &lt;/span&gt;
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-PullRequest승인절차&quot;&gt;
 Pull Request 승인 절차
&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Pull Request는 Master Branch에 Merge를 하기위한 절차입니다.
 &lt;/li&gt;
 &lt;li&gt;
  코드 리뷰를 통해서 품질을 향상 시키고 협업을 촉진 시킬 수 있어요
 &lt;/li&gt;
 &lt;li&gt;
  Jira Software는 Branch History와 이슈를 연결하여 보는 최고의 툴입니다.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/33.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/34.png&quot;/&gt;
  &lt;/span&gt;
  &lt;br/&gt;
  Jira에서 분기점을 만들어 보세요.
  &lt;br/&gt;
  &lt;br/&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/35.png&quot;/&gt;
  &lt;/span&gt;
  &lt;br/&gt;
  Bitbucket 과 Application연결이 됐을 때 가능합니다.
  &lt;br/&gt;
  Master Branch에서 Issue key + summray로 생성되네요
  &lt;br/&gt;
  생성 후 Jira에서 Tracking 할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/36.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/li&gt;
 &lt;li&gt;
  Jira에서 Git 상태를 확인하는게 중요합니다.
 &lt;/li&gt;
 &lt;li&gt;
  프로덕트 오너, 리더 등 매니저 그룹은 개발자보다 이슈에 더 포커싱이 되어 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  Jira에서 이슈를 확인하고 코드를 확인하는 절차를 갖을 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  다른 동료 개발자들도 이슈와 코드를 Jira에서 이슈 상태와 함께 공유할 수 있기 때문에 협업 문화를 잘 구축할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/63373558/37.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  개발이 끝나고 Pull Request를 생성하고 Reviewer를 지정하여 승인 절차를 받을 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  PR(Pull Request)는 협업 문화, 코드 품질 향상 등 장점이 많습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;AtlassianCI/CDStepByStep-Wrapup&quot;&gt;
 Wrap up
&lt;/h2&gt;
&lt;ul style=&quot;list-style-type: square;&quot;&gt;
 &lt;li&gt;
  Jira에서 생성된
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-Bamboo&quot;&gt;
 Bamboo
&lt;/h1&gt;
&lt;p&gt;
 &lt;span style=&quot;color: rgb(80,95,121);&quot;&gt;
  Bamboo Server는
 &lt;/span&gt;
 &lt;em style=&quot;text-align: center;&quot;&gt;
  프로페셔널 팀
 &lt;/em&gt;
 &lt;span style=&quot;color: rgb(80,95,121);&quot;&gt;
  이 지속적 통합, 배포를 위해 선택하는 제품입니다.
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 아틀라시안 제품과 강력하게 통합하여 자동화 빌드/배포 환경을 구축할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 자동화의 목적은 빠른 빌드/배포를 자주하는 것 입니다.
&lt;/p&gt;
&lt;p&gt;
 개발팀과 운영팀은 더 이상 배포는 두려움의 대상이 아닙니다.
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-Project&quot;&gt;
 Project
&lt;/h1&gt;
&lt;p&gt;
 Plans의 모음입니다. 논리적으로 관련된 계획을 쉽게 그룹화하고 식별 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 프로젝트 단위로 접근 권한을 설정하여 액세스를 쉽게 제어 할 수 있습니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  n개의 계획을 포함합니다.
 &lt;/li&gt;
 &lt;li&gt;
  프로젝트는 Reports를 제공합니다.
 &lt;/li&gt;
 &lt;li&gt;
  Plan에 포함 된 권한을 설정할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/38.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &amp;lt;project settings&amp;gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/39.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  Project details
 &lt;/li&gt;
 &lt;li&gt;
  Project permissions
 &lt;/li&gt;
 &lt;li&gt;
  Plan permissions inheritance
 &lt;/li&gt;
 &lt;li&gt;
  Bamboo Specs repositories
 &lt;/li&gt;
 &lt;li&gt;
  Application links
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 Bamboo Project Admin을 설정하여 Admin이 Bamboo Plan, Repositories 접근 권한을 설정할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Application 개발자에게 한정적인 빌드, 배포 권한을 부여함으로써 Ops팀과 Dev팀의 차이를 줄일 수 있습니다.
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-Plan&quot;&gt;
 Plan
&lt;/h1&gt;
&lt;p&gt;
 지속통합, 빌드 프로세스를 정의합니다.
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  기본적으로 하나의 stage로 구성되어 있지만, 여러개의 jobs을 여러 stage로 구성할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  하나의 Repository를 사용하여 순차적으로 실행되는 하나 이상의 stage를 처리합니다.
 &lt;/li&gt;
 &lt;li&gt;
  기본 Repository를 지정합니다.
 &lt;/li&gt;
 &lt;li&gt;
  빌드가 트리거되는 방법과 프로젝트의 계획과 다른 계획 간의 트리거 종속성을 지정합니다.
 &lt;/li&gt;
 &lt;li&gt;
  빌드 결과에 대한 알림을 지정합니다.
  &lt;ul&gt;
   &lt;li&gt;
    메일 또는 메신저
   &lt;/li&gt;
  &lt;/ul&gt;
 &lt;/li&gt;
 &lt;li&gt;
  Plan, jobs 설정 및 보기 권한을 설정할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  Plan variables를 설정할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/40.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;Create stage&amp;gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  stage를 추가할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-Stage&quot;&gt;
 Stage
&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;
  하나의 Plan에는 각 단계에 대한 stage를 정의할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  예를들어, 컴파일 단계와 몇가지 테스트 단계, 배포 단계로 구성된 전반적인 Plan 빌드프로세스가 있을 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  기본적으로는 Default job이 있지만 여러 작업을 그룹화 하는데 사용할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  여러 Agent에서 병렬처리 할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  다음 Stage를 처리하기 위해서는 모든 작업을 성공적으로 완료해야 합니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-Job&quot;&gt;
 Job
&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;
  Plan 내의 단일 빌드 단위입니다.
 &lt;/li&gt;
 &lt;li&gt;
  하나 이상의 작업을 Bamboo Agent로 순차 또는 병렬 처리할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  작업이 수행되는 순서를 제어합니다.
 &lt;/li&gt;
 &lt;li&gt;
  job에 각 tast가 필요한 값으로 agent를 선택적으로 실행할 수 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  &lt;span class=&quot;confluence-link&quot; style=&quot;color: rgb(23,43,77);&quot;&gt;
   artifacts를 생성하여
  &lt;/span&gt;
  stage가 실행될 때 사용할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 class=&quot;page-title&quot; id=&quot;AtlassianCI/CDStepByStep-Deploymentprojects&quot;&gt;
 Deployment projects
&lt;/h1&gt;
&lt;ul&gt;
 &lt;li&gt;
  배포 프로젝트의 계획을 쉽게 만들 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
   &lt;img src=&quot;/assets/images/63373558/41.png&quot;/&gt;
  &lt;/span&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 &amp;lt;빌드 배포 전략 예시&amp;gt;
&lt;/p&gt;
&lt;ul&gt;
 &lt;li&gt;
  배포는 다음을 포함하는 컨테이너 입니다.
 &lt;/li&gt;
 &lt;li&gt;
  Development, Staging, Production과 같은 물리적 환경을 나타냅니다.
 &lt;/li&gt;
 &lt;li&gt;
  배포 중인 실제 소프트웨어 artifacts를 나타내는 릴리즈 - 릴리즈를 구성하는 이슈, 및 커밋 내역을 포함하고 있습니다.
 &lt;/li&gt;
 &lt;li&gt;
  Plan의 통합 빌드, 배포를 workflow로 정의할 수 있습니다.
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;AtlassianCI/CDStepByStep-마무리&quot;&gt;
 마무리
&lt;/h1&gt;
&lt;p&gt;
 요즘 DevOps 의 기술적인 부분인 CI/CD는 많은 관심을 받고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 많은 자본과 인력을 가진 회사가 항상 좋은 소프트웨어를 누구보다 더 빠르게 만들 수 있을까요?
&lt;/p&gt;
&lt;p&gt;
 요즘 많은 스타트업들이 적은 자본과 인력으로 많은 서비스를 내놓고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 우리는 비용 절감을 이야기하지 않습니다. 덩치가 커진 회사는 민첩함을 잃고 부서의 성과에 집중하게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 DevOps, CI/CD, Agile 등은 팀에게 민첩함을 부여하고 공통된 성과에 집중하도록 합니다.
&lt;/p&gt;
&lt;p&gt;
 그러기 위해서는 문화, 기술의 변화가 필요합니다.
&lt;/p&gt;
&lt;p&gt;
 짧은 글로는 시작하기도 힘들어요 책을 수십 권 읽어도 시작하기 힘들어요
&lt;/p&gt;
&lt;p&gt;
 많은 시행착오와 노하우를 갖고 있는 파트너가 필요합니다.
&lt;/p&gt;
&lt;p&gt;
 조직 문화와 기술에 변화를 갖는데 어려움을 갖고 계신다면
&lt;/p&gt;
&lt;p&gt;
 커피한잔 어떠세요?
&lt;/p&gt;
&lt;p&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;mailto:atlassian@osci.kr&quot; rel=&quot;nofollow&quot;&gt;
  atlassian@osci.kr
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 감사합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Thu, 28 Feb 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/02/28/63373558/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/28/63373558/</guid>
        
        <category>atlassian</category>
        
        <category>ci/cd</category>
        
        
      </item>
    
      <item>
        <title>Docker Swarm 을 이용한 Container Orchestration 환경 만들기</title>
        <description>&lt;p&gt;
 안녕하세요? 오픈소스컨설팅 한철희 과장입니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이전 &quot;
 &lt;strong&gt;
  Docker 이해하기
 &lt;/strong&gt;
 &quot; 를 포스팅에 이어, &quot;
 &lt;strong&gt;
  Docker Swarm 을 이용한 Container Orchestration 환경 만들기
 &lt;/strong&gt;
 &quot; 라는 포스팅을 작성하게 되었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;em&gt;
  (Review -
  &lt;a class=&quot;external-link&quot; href=&quot;https://tech.osci.kr/docker/2018/09/10/45749387/&quot; rel=&quot;nofollow&quot;&gt;
   Docker 이해하기
  &lt;/a&gt;
 &lt;/em&gt;
 )
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이전 포스팅에서 Docker 를 직접 사용하면서 여러 장점을 확인했습니다.
&lt;/p&gt;
&lt;p&gt;
 하지만 과연 실무에 적용하면 안정적으로 서비스를 유지하고 운영할 수 있을지에 대해서는 의문을 가지고 있었습니다.
&lt;/p&gt;
&lt;p&gt;
 이러한 의문은 Container 들을 자동으로 관리하게 해주는
 &lt;em&gt;
  Container
 &lt;/em&gt;
 &lt;em&gt;
  Orchestration Tool
 &lt;/em&gt;
 을 활용함으로써 해결을 하게 되었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-ContainerOrchestration&quot;&gt;
 &lt;em&gt;
  Container Orchestration
 &lt;/em&gt;
&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/0.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 컨테이너 오케스트레이션 이란? 다중 컨테이너 패키지 어플리케이션을 배포하는 동안 사용되는 컨테이너, 리소스의 자동화, 정렬, 조정 및 관리를 하는 것을 말합니다.
&lt;/p&gt;
&lt;p&gt;
 위와 같이 많은 오케스트레이션 도구들이 있습니다. 이번 포스팅에서는 쉽게 구성이 가능한 Docker Swarm 을 통해 컨테이너 오케스트레이션을 맛보려고 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarm&quot;&gt;
 Docker Swarm
&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/1.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 Docker Swarm 이란?
&lt;/p&gt;
&lt;p&gt;
 수많은 컨테이너 오케스트레이션 도구 중의 하나로, 여러 대의 Docker 호스트들을 마치 하나인 것처럼 만들어주는 Orchestration 도구입니다.
&lt;/p&gt;
&lt;p&gt;
 Docker v1.12 이후부터 Docker Swarm Mode 로 별개의 Docker Swarm 엔진에서 Docker 엔진으로 통합되면서 좀 더 간편한 설치가 가능해졌습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 쉬워진 Docker Swarm 직접 설치 해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarm설치&quot;&gt;
 Docker Swarm 설치
&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/2.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p style=&quot;text-align: center;&quot;&gt;
 (Docker Document, How nodes work -
 &lt;a class=&quot;external-link&quot; href=&quot;https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/&quot; rel=&quot;nofollow&quot;&gt;
  https://docs.docker.com/engine/swarm/how-swarm-mode-works/nodes/)
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 위와 같이 기본적으로 Docker Swarm 은 Master 노드와 Worker 노드로 시스템을 구성합니다.
&lt;/p&gt;
&lt;p&gt;
 Master 노드에서는 클러스터 관리 작업을 하고 클러스터 상태 유지, 스케줄링 서비스, Swarm HTTP API Endpoint 를 제공합니다.
&lt;/p&gt;
&lt;p&gt;
 Worker 노드는 컨테이너를 실행하는 역할만 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이번 Master 노드를 Three-Manager 구성으로 하여 컨테이너 오케스트레이션 및 Docker Swarm 안정성에 대해 확인해보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;panel conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;panel&quot; style=&quot;border-color: black;border-style: dashed;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;panelHeader&quot; style=&quot;border-bottom-width: 1px;border-bottom-style: dashed;border-bottom-color: black;&quot;&gt;
  &lt;b&gt;
   System Environment
  &lt;/b&gt;
 &lt;/div&gt;
 &lt;div class=&quot;panelContent&quot;&gt;
  &lt;p&gt;
   OS : CentOS Linux release 7.6.1810 (Core)
  &lt;/p&gt;
  &lt;p&gt;
   Docker Version : docker-1.13.1-88.git07f3374.el7.centos.x86_64
  &lt;/p&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/3.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 위와 같이 시스템 환경으로 Three-Manager 구성을 하도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 Docker Swarm 이 Docker 엔진과 통합되면서 설치는 일반적인 Docker 설치와 동일해졌습니다.
&lt;/p&gt;
&lt;p&gt;
 설치는 아래와 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # yum -y install docker
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# yum -y install docker

&amp;lt;중략&amp;gt;

Installed:
  docker.x86_64 2:1.13.1-88.git07f3374.el7.centos

Dependency Installed:
  PyYAML.x86_64 0:3.10-11.el7                                                     atomic-registries.x86_64 1:1.22.1-26.gitb507039.el7.centos            audit-libs-python.x86_64 0:2.8.4-4.el7                               checkpolicy.x86_64 0:2.5-8.el7
  container-selinux.noarch 2:2.74-1.el7                                           container-storage-setup.noarch 0:0.11.0-2.git5eaf76c.el7              containers-common.x86_64 1:0.1.31-7.gitb0b750d.el7.centos            docker-client.x86_64 2:1.13.1-88.git07f3374.el7.centos
  docker-common.x86_64 2:1.13.1-88.git07f3374.el7.centos                          libcgroup.x86_64 0:0.41-20.el7                                        libseccomp.x86_64 0:2.3.1-3.el7                                      libsemanage-python.x86_64 0:2.5-14.el7
  libyaml.x86_64 0:0.1.4-11.el7_0                                                 oci-register-machine.x86_64 1:0-6.git2b44233.el7                      oci-systemd-hook.x86_64 1:0.1.18-2.git3efe246.el7                    oci-umount.x86_64 2:2.3.4-2.git87f9237.el7
  policycoreutils-python.x86_64 0:2.5-29.el7_6.1                                  python-IPy.noarch 0:0.75-6.el7                                        python-backports.x86_64 0:1.0-8.el7                                  python-backports-ssl_match_hostname.noarch 0:3.5.0.1-1.el7
  python-ipaddress.noarch 0:1.0.16-2.el7                                          python-pytoml.noarch 0:0.1.14-1.git7dea353.el7                        python-setuptools.noarch 0:0.9.8-7.el7                               setools-libs.x86_64 0:3.3.8-4.el7
  subscription-manager-rhsm-certificates.x86_64 0:1.21.10-3.el7.centos            yajl.x86_64 0:2.0.4-4.el7

Dependency Updated:
  policycoreutils.x86_64 0:2.5-29.el7_6.1

Complete!

[root@manager1 ~]# systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
[root@manager1 ~]# systemctl start docker
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 위와 같이 모든 Master 노드에 동일하게 설치를 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# systemctl enable docker
Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.
[root@manager1 ~]# systemctl start docker&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # systemctl enable docker
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # systemctl start docker
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 각 노드 별로 Docker 서비스를 시작합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# systemctl status docker
● docker.service - Docker Application Container Engine
   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)
   Active: active (running) since 월 2019-02-11 14:14:37 KST; 2min 54s ago
     Docs: http://docs.docker.com
 Main PID: 14694 (dockerd-current)
   CGroup: /system.slice/docker.service
           ├─14694 /usr/bin/dockerd-current --add-runtime docker-runc=/usr/libexec/docker/docker-runc-current --default-runtime=docker-runc --exec-opt native.cgroupdriver=systemd --userland-proxy-path=/usr/libexec/docker/docker-proxy-current --init-path=/usr/libexec/docker/docker-init-cu...
           └─14701 /usr/bin/docker-containerd-current -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metrics-interval=0 --start-timeout 2m --state-dir /var/run/docker/libcontainerd/containerd --shim docker-containerd-shim --runtime docker-runc --runtime-args --systemd-c...

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # systemctl status docker
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 설치가 완료되면 Docker 서비스를 시작하고 위와 같이 정상적으로 시작되었는지 확인합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarminit&quot;&gt;
 Docker Swarm init
&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;
 Docker Swarm 를 구성하기 위해 아래와 같이 명령 수행을 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker swarm init --advertise-addr [Manager Node IP]
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# docker swarm init --advertise-addr 192.168.13.176
Swarm initialized: current node (y8ul9r3jq0rgt9k3vbvrayeyg) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2m3tqsm8ly45vpd5i80p4bkor5zaohfmultu4cdnvfpg8yxmuk-bv8adgschaygmg9icehekb9wg \
    192.168.13.176:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 위와 같이 초기화를 진행하면 Worker 노드를 추가하는 token 값으로 명령어가 자동 생성됩니다.
&lt;/p&gt;
&lt;p&gt;
 해당 명령을 Worker 노드에 입력하면 해당 노드는 Worker 노드가 됩니다.
&lt;/p&gt;
&lt;p&gt;
 Master 노드(Manager 노드)를 추가하기 위해서는
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker swarm join-token manager
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 명령을 통해 명령어를 생성해야됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;# docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join \
    --token SWMTKN-1-2m3tqsm8ly45vpd5i80p4bkor5zaohfmultu4cdnvfpg8yxmuk-9ghru6puwdvqms3bn7zqtiyvt \
    192.168.13.176:2377&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 Manager 연결을 위해 생성된 명령을 나머지 Manager 노드에 아래와 같이 입력합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager2 ~]#     docker swarm join \
&amp;gt;     --token SWMTKN-1-2m3tqsm8ly45vpd5i80p4bkor5zaohfmultu4cdnvfpg8yxmuk-9ghru6puwdvqms3bn7zqtiyvt \
&amp;gt;     192.168.13.176:2377
This node joined a swarm as a manager.

[root@manager3 ~]#     docker swarm join \
&amp;gt;     --token SWMTKN-1-2m3tqsm8ly45vpd5i80p4bkor5zaohfmultu4cdnvfpg8yxmuk-9ghru6puwdvqms3bn7zqtiyvt \
&amp;gt;     192.168.13.176:2377
This node joined a swarm as a manager.
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarm구성확인&quot;&gt;
 Docker Swarm 구성 확인
&lt;/h2&gt;
&lt;hr/&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# docker node ls
ID                           HOSTNAME              STATUS  AVAILABILITY  MANAGER STATUS
lrt89xwkugty162qk8c2av5ek    manager2.example.com  Ready   Active        Reachable
y8ul9r3jq0rgt9k3vbvrayeyg *  manager1.example.com  Ready   Active        Leader
yqerq5ujds38t0izzlp03dbhd    manager3.example.com  Ready   Active        Reachable

&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker node ls
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 위와 같이 manager 로 노드들이 연결된 것을 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarm기본사용법&quot;&gt;
 Docker Swarm 기본 사용법
&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;
 Docker Swarm 에서 사용되는 기본적인 명령을 간단한 Apache 서비스를 기동하면서 확인 해보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarmService생성&quot;&gt;
 Docker Swarm Service 생성
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 Docker Swarm 명령어는 기존의 docker 명령어와 크게 다른 점은 없습니다.
&lt;/p&gt;
&lt;p&gt;
 기본적으로 docker run 에서 사용되는 옵션을 그대로 사용 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;br/&gt;
 &lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
 아래 명령을 통해 Docker Swarm Mode 로 컨테이너를 실행 할 수 있습니다.
 &lt;em&gt;
  &lt;br/&gt;
 &lt;/em&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   Usage:  docker service create [OPTIONS] IMAGE [COMMAND] [ARG...]
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# docker service create --name web httpd
xocc6zwdulliijqpypwby764d&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarmService확인&quot;&gt;
 Docker Swarm Service 확인
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 생성된 서비스가 정상적으로 실행이 되었는지는 아래 명령으로 확인이 가능합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   Usage:    docker service ls
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# docker service ls
ID            NAME  MODE        REPLICAS  IMAGE
xocc6zwdulli  web   replicated  0/1       httpd:latest
[root@manager1 ~]# docker service ls
ID            NAME  MODE        REPLICAS  IMAGE
xocc6zwdulli  web   replicated  1/1       httpd:latest&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 처음 REPLICAS 필드가 0/1 로 시작해서 1/1 로 변경이 되면 컨테이너가 정상적으로 실행이 된 것으로 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 해당 필드를 통해 컨테이너가 문제가 생겼는지 정상 작동 중인지 확인이 가능합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 또한 각 서비스 별로 자세한 정보를 확인하는 명령은 아래와 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   Usage:    docker service ps [SERVICE]
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# docker service ps web
ID            NAME   IMAGE         NODE                  DESIRED STATE  CURRENT STATE          ERROR  PORTS
9x3qvcl5seif  web.1  httpd:latest  manager2.example.com  Running        Running 2 minutes ago&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarmServiceScale-out&quot;&gt;
 Docker Swarm Service Scale-out
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 생성된 서비스를 복제하여 분산 서비스를 할 수 있도록 합니다.(Scale-out)
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   Usage:  docker service scale SERVICE=REPLICAS [SERVICE=REPLICAS...]
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# docker service scale web=3
web scaled to 3

[root@manager1 ~]# docker service ls
ID            NAME  MODE        REPLICAS  IMAGE
xocc6zwdulli  web   replicated  1/3       httpd:latest

[root@manager1 ~]# docker service ls
ID            NAME  MODE        REPLICAS  IMAGE
xocc6zwdulli  web   replicated  3/3       httpd:latest

[root@manager1 ~]# for i in $(cat /etc/hosts | grep manager| awk '{print $1}')
&amp;gt; do
&amp;gt; ssh root@$i &quot;docker ps -a&quot;
&amp;gt; done
CONTAINER ID        IMAGE                                                                           COMMAND              CREATED             STATUS              PORTS               NAMES
e517f6af9ebd        httpd@sha256:d12c036427f436978f2d4397ad2bd6b5b8f7b03003b7a1da084eb228ef25b7d2   &quot;httpd-foreground&quot;   5 minutes ago       Up 5 minutes        80/tcp              web.2.57p0vzbkqymvak5t5rw6g42k9
CONTAINER ID        IMAGE                                                                           COMMAND              CREATED             STATUS              PORTS               NAMES
91dddedf7374        httpd@sha256:d12c036427f436978f2d4397ad2bd6b5b8f7b03003b7a1da084eb228ef25b7d2   &quot;httpd-foreground&quot;   9 minutes ago       Up 9 minutes        80/tcp              web.1.9x3qvcl5seifoidt5jy4fm3oa
CONTAINER ID        IMAGE                                                                           COMMAND              CREATED             STATUS              PORTS               NAMES
2a3ade0887f9        httpd@sha256:d12c036427f436978f2d4397ad2bd6b5b8f7b03003b7a1da084eb228ef25b7d2   &quot;httpd-foreground&quot;   5 minutes ago       Up 5 minutes        80/tcp              web.3.aqlqfena08g9c50tdl5vgb4ju

[root@manager1 ~]# docker service ps web
ID            NAME   IMAGE         NODE                  DESIRED STATE  CURRENT STATE          ERROR  PORTS
9x3qvcl5seif  web.1  httpd:latest  manager2.example.com  Running        Running 9 minutes ago
57p0vzbkqymv  web.2  httpd:latest  manager1.example.com  Running        Running 6 minutes ago
aqlqfena08g9  web.3  httpd:latest  manager3.example.com  Running        Running 6 minutes ago
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerSwarmService제거&quot;&gt;
 Docker Swarm Service 제거
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 생성한 서비스의 제거 및 종료는 아래 명령을 통해 가능합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   Usage:  docker service rm SERVICE [SERVICE...]
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 ~]# docker service rm web
web
[root@manager1 ~]# docker service ls
ID  NAME  MODE  REPLICAS  IMAGE
[root@manager1 ~]# docker service ps web
Error: No such service: web
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 지금까지 Docker Swarm 에서 많이 사용되는 명령어들을 보면서 간단한 웹 서비스를 구성하였습니다.
&lt;/p&gt;
&lt;p&gt;
 이제부터는 Build 된 PHP Docker Image를 이용해서 Docker Swarm 을 어떻게 실무에 적용 할 수 있는지 확인해 보도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-PHPDemo&quot;&gt;
 PHP Demo
&lt;/h1&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerImage관리를위한사설Registry생성&quot;&gt;
 Docker Image 관리를 위한 사설 Registry 생성
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 각 Docker Host 노드에 같은 이미지를 배포 하기 위해서는 두가지 방법이 있습니다.
&lt;/p&gt;
&lt;p&gt;
 그 방법은 DockerHub 를 활용하는 방법 및 사설 Registry 를 만들어서 사용하는 방법입니다.
&lt;/p&gt;
&lt;p&gt;
 어떤 방법을 사용하는 것이 좋을지는 운영 환경에 맞게 선택을 하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 이번 PHP Demo 에서는 사설 Registry 를 생성하여 Docker Image 를 관리하도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 먼저 Docker Registry 를 생성하기 전에 insecure-registries 옵션을 설정하여 인증되지 않은 Registry를 사용 할 수 있도록 해야됩니다.
&lt;/p&gt;
&lt;p&gt;
 이미지를 사용해야되는 모든 노드를 아래와 같이 수정을 합니다. 이후 docker 서비스를 재시작합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;# vi /etc/docker/daemon.json
{
  &quot;insecure-registries&quot; : [&quot;manager1.example.com:5000&quot;]
}
# systemctl restart docker&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 위와 같이 manager1.example.com 만 선택을 하였는데 Load Balancer 가 있다면 해당 IP 혹은 Domain 명을 추가해도 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 사설 Registry 를 생성하기 위해서는 아래와 같이 진행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker service create --name registry -p 5000:5000 registry
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;# docker service create --name registry -p 5000:5000 registry
z3gl3pie7xm9vjfyetot9zi3q

[root@manager1 ~]# docker service ls
ID            NAME      MODE        REPLICAS  IMAGE
z3gl3pie7xm9  registry  replicated  1/1       registry:latest

[root@manager1 dockerfile]# docker service ps registry
ID            NAME        IMAGE            NODE                  DESIRED STATE  CURRENT STATE          ERROR  PORTS
ct6zhchfla8s  registry.1  registry:latest  manager3.example.com  Running        Running 6 minutes ago
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 위와 같이 현재 manager3.example.com Docker Host 에 컨테이너가 실행중인 것을 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-BuildTheDockerImage&quot;&gt;
 Build The Docker Image
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 아래와 같이 Dockerfile을 생성하여 PHP 서비스가 가능한 Docker Image 를 Build 합니다.
&lt;/p&gt;
&lt;p style=&quot;margin-left: 30.0px;&quot;&gt;
 &amp;gt; 참고로 아래 사용된 예제 파일은 github 에서 Clone 할 수 있습니다.
&lt;/p&gt;
&lt;p style=&quot;margin-left: 30.0px;&quot;&gt;
 &lt;span&gt;
  &amp;gt;
 &lt;/span&gt;
 &lt;a class=&quot;external-link&quot; href=&quot;https://github.com/chhanz/docker-swarm-demo&quot; rel=&quot;nofollow&quot;&gt;
  &lt;span&gt;
   https://github.com/chhanz/docker-swarm-demo
  &lt;/span&gt;
 &lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 PHP Demo 에 사용되는 파일 구성 및 내용은 아래와 같습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# tree
.
├── Dockerfile
├── README.md
└── htdocs
    └── index.php

1 directory, 3 files

# vi Dockerfile
FROM php:7.2-apache
MAINTAINER chhanz &amp;lt;chhan@osci.kr&amp;gt;

ADD htdocs/index.php /var/www/html/index.php

EXPOSE 80

[root@manager1 docker-swarm-demo]# cat htdocs/index.php
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;
&amp;lt;b&amp;gt;
&amp;lt;?php
$host=gethostname();
echo &quot;Container Name : &quot;;
echo $host;
?&amp;gt;
&amp;lt;p&amp;gt; Image Version : orignal&amp;lt;/p&amp;gt;
&amp;lt;/b&amp;gt;
&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 제가 포스팅한 내용을 보신 분이라면 Docker Build는 어렵지 않습니다. ㅎㅎ
&lt;/p&gt;
&lt;p&gt;
 Image 를 Build 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker build -t phpdemo:v1 .
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker build -t phpdemo:v1 .
Sending build context to Docker daemon 4.608 kB
Step 1/4 : FROM php:7.2-apache
 ---&amp;gt; 2424d6c5e6b9
Step 2/4 : MAINTAINER chhanz &amp;lt;chhan@osci.kr&amp;gt;
 ---&amp;gt; Running in 1257b21144c7
 ---&amp;gt; 2beeadfdb912
Removing intermediate container 1257b21144c7
Step 3/4 : ADD htdocs/index.php /var/www/html/index.php
 ---&amp;gt; 62a4d63e0c2f
Removing intermediate container 06a5fe09c5c5
Step 4/4 : EXPOSE 80
 ---&amp;gt; Running in 310137303fa5
 ---&amp;gt; c62e0ad19807
Removing intermediate container 310137303fa5
Successfully built c62e0ad19807
[root@manager1 docker-swarm-demo]#&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 Build 가 완료된 Image 를 사설 Registry 에 Push 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   // Docker Image Tag 변경
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p style=&quot;margin-left: 30.0px;&quot;&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker tag phpdemo:v1 manager1.example.com:5000/phpdemo:v1
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   // Docker Image Push
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p style=&quot;margin-left: 30.0px;&quot;&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker push manager1.example.com:5000/phpdemo:v1
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker images
REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
phpdemo              v1                  c62e0ad19807        18 seconds ago      378 MB
docker.io/php        7.2-apache          2424d6c5e6b9        3 days ago          378 MB
docker.io/registry   &amp;lt;none&amp;gt;              d0eed8dad114        12 days ago         25.8 MB
[root@manager1 docker-swarm-demo]# docker tag phpdemo:v1 manager1.example.com:5000/phpdemo:v1
[root@manager1 docker-swarm-demo]# docker images
REPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE
manager1.example.com:5000/phpdemo   v1                  c62e0ad19807        30 seconds ago      378 MB
phpdemo                             v1                  c62e0ad19807        30 seconds ago      378 MB
docker.io/php                       7.2-apache          2424d6c5e6b9        3 days ago          378 MB
docker.io/registry                  &amp;lt;none&amp;gt;              d0eed8dad114        12 days ago         25.8 MB
[root@manager1 docker-swarm-demo]# docker push manager1.example.com:5000/phpdemo:v1
The push refers to a repository [manager1.example.com:5000/phpdemo]
a0df0b1bee34: Pushed
29f6f251b4d2: Pushed
28255a6692d8: Pushed
d9b14cb17d8b: Pushed
725c91d33681: Pushed
005a87a63ac9: Pushed
66fd43b3ea3b: Pushed
20d941ba3638: Pushed
eb3e3e0ec224: Pushed
3843f6b0eab9: Pushed
63fc1837f67c: Pushed
c68025fbc229: Pushed
ec6f4f0a90dc: Pushed
0a07e81f5da3: Pushed
v1: digest: sha256:58b33a5f39d60a3f0ba860a1bcbc98f5f767d934c9b1c057cee4b8c1a192fd06 size: 3242
[root@manager1 docker-swarm-demo]#&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-서비스배포!&quot;&gt;
 서비스 배포!
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 생성된 따끈한 Image 를 이용해서 Docker Swarm Mode 로 서비스를 배포하도록 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker service create --name phpdemo -p 80:80 manager1.example.com:5000/phpdemo:v1
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker service create --name phpdemo -p 80:80 manager1.example.com:5000/phpdemo:v1
mcz67fbul4gmxtjtwc4dvf4n2

// 서비스 시작 중
[root@manager1 docker-swarm-demo]# docker service ls
ID            NAME      MODE        REPLICAS  IMAGE
mcz67fbul4gm  phpdemo   replicated  0/1       manager1.example.com:5000/phpdemo:v1
z3gl3pie7xm9  registry  replicated  1/1       registry:latest
[root@manager1 docker-swarm-demo]# docker service ps phpdemo
ID            NAME       IMAGE                                 NODE                  DESIRED STATE  CURRENT STATE            ERROR  PORTS
m82bq5rgmk7z  phpdemo.1  manager1.example.com:5000/phpdemo:v1  manager2.example.com  Running        Preparing 7 seconds ago

// 서비스 시작 완료
[root@manager1 docker-swarm-demo]# docker service ls
ID            NAME      MODE        REPLICAS  IMAGE
mcz67fbul4gm  phpdemo   replicated  1/1       manager1.example.com:5000/phpdemo:v1
z3gl3pie7xm9  registry  replicated  1/1       registry:latest

[root@manager1 docker-swarm-demo]# docker service ps phpdemo
ID            NAME       IMAGE                                 NODE                  DESIRED STATE  CURRENT STATE          ERROR  PORTS
m82bq5rgmk7z  phpdemo.1  manager1.example.com:5000/phpdemo:v1  manager2.example.com  Running        Running 2 seconds ago
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/4.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 직접 웹브라우져를 통해 접속해보니 서비스가 정상적으로 작동 되는 것을 확인 할 수 있었습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-서비스복제!&quot;&gt;
 서비스 복제!
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 컨터이너 한개로 서비스를 하기에는 안정성이 너무나도 떨어지고 성능 향상을 위해 컨테이너를 복제합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;strong&gt;
   # docker service scale phpdemo=3
  &lt;/strong&gt;
 &lt;/em&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker service ls
ID            NAME      MODE        REPLICAS  IMAGE
mcz67fbul4gm  phpdemo   replicated  1/1       manager1.example.com:5000/phpdemo:v1
z3gl3pie7xm9  registry  replicated  1/1       registry:latest

// 서비스 복제
[root@manager1 docker-swarm-demo]# docker service scale phpdemo=3
phpdemo scaled to 3

[root@manager1 docker-swarm-demo]# docker service ls
ID            NAME      MODE        REPLICAS  IMAGE
mcz67fbul4gm  phpdemo   replicated  3/3       manager1.example.com:5000/phpdemo:v1
z3gl3pie7xm9  registry  replicated  1/1       registry:latest
[root@manager1 docker-swarm-demo]#

[root@manager1 docker-swarm-demo]# docker service ps phpdemo
ID            NAME       IMAGE                                 NODE                  DESIRED STATE  CURRENT STATE                   ERROR  PORTS
m82bq5rgmk7z  phpdemo.1  manager1.example.com:5000/phpdemo:v1  manager2.example.com  Running        Running 2 minutes ago
09p9qrtxidnw  phpdemo.2  manager1.example.com:5000/phpdemo:v1  manager3.example.com  Running        Running less than a second ago
8x0pcftmzbzw  phpdemo.3  manager1.example.com:5000/phpdemo:v1  manager1.example.com  Running        Running 11 seconds ago
[root@manager1 docker-swarm-demo]#&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 위와 같이 서비스가 복제가 된 것을 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 그럼 실제로 어떻게 서비스가 운영되는지 확인해보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  3 Replica 서비스
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/5.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (상기 GIF 파일은 용량이 커서, 출력이 느릴수도 있습니다.)
&lt;/p&gt;
&lt;p&gt;
 보시는 것과 같이 각기 다른 컨테이너로 Load Balancing 되는 것을 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 위와 같이 Docker Swarm 이 각기 다른 Docker Host를 Load Balancing 를 하는 이유는 아래와 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper image-center-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/6.png&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 무언가 엄청 복잡해 보이지만 결국은 Ingress Network 를 통해 지정된 포트의 통신은 해당 컨테이너로 자동으로 전달이 될 것입니다.
&lt;/p&gt;
&lt;p&gt;
 자세한 Network Architecture 는 아래 Docker Document 를 확인하는 것이 좋습니다.
&lt;/p&gt;
&lt;p&gt;
 (
 &lt;a class=&quot;external-link&quot; href=&quot;https://success.docker.com/article/networking&quot; rel=&quot;nofollow&quot;&gt;
  https://success.docker.com/article/networking
 &lt;/a&gt;
 )
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-서비스RollingUpdate&quot;&gt;
 서비스 Rolling Update
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 서비스를 운영하다보면 업데이트가 필요로한 시기가 있습니다.
&lt;/p&gt;
&lt;p&gt;
 하지만 운영중에 서비스를 중지하고 업데이트를 하는 것은 서비스 DownTime 이 발생하게 되고 그만큼 운영에 힘들게 됩니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 우리 Docker Swarm 과 함께라면 운영중에 서비스를 업데이트가 가능합니다!!!
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 먼저 기존에 만들어진 Docker Image 를 업데이트하도록 하겠습니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# cat htdocs/index.php
&amp;lt;html&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;
&amp;lt;b&amp;gt;
&amp;lt;?php
$host=gethostname();
echo &quot;Container Name : &quot;;
echo $host;
?&amp;gt;
&amp;lt;p&amp;gt; Image Version : Update Version v2&amp;lt;/p&amp;gt;
&amp;lt;/b&amp;gt;
&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;auto-cursor-target&quot;&gt;
 핵심 파일인 Index.php 를 수정을 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker build -t phpdemo:v2 .
Sending build context to Docker daemon 4.608 kB
Step 1/4 : FROM php:7.2-apache
 ---&amp;gt; 2424d6c5e6b9
Step 2/4 : MAINTAINER chhanz &amp;lt;chhan@osci.kr&amp;gt;
 ---&amp;gt; Using cache
 ---&amp;gt; 2beeadfdb912
Step 3/4 : ADD htdocs/index.php /var/www/html/index.php
 ---&amp;gt; 723bb4020994
Removing intermediate container ef8133b39a77
Step 4/4 : EXPOSE 80
 ---&amp;gt; Running in 14a08f850b38
 ---&amp;gt; 99574ad1473c
Removing intermediate container 14a08f850b38
Successfully built 99574ad1473c
[root@manager1 docker-swarm-demo]# docker images
REPOSITORY                          TAG                 IMAGE ID            CREATED             SIZE
phpdemo                             v2                  99574ad1473c        5 seconds ago       378 MB
manager1.example.com:5000/phpdemo   v1                  c62e0ad19807        16 minutes ago      378 MB
phpdemo                             v1                  c62e0ad19807        16 minutes ago      378 MB
docker.io/php                       7.2-apache          2424d6c5e6b9        3 days ago          378 MB
docker.io/registry                  &amp;lt;none&amp;gt;              d0eed8dad114        12 days ago         25.8 MB
[root@manager1 docker-swarm-demo]#
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 phpdemo:v2 로 Tag 를 지정하고 신규로 생성된 Image 를 Push 합니다.
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker tag phpdemo:v2 manager1.example.com:5000/phpdemo:v2

[root@manager1 docker-swarm-demo]# docker images
REPOSITORY                          TAG                 IMAGE ID            CREATED              SIZE
manager1.example.com:5000/phpdemo   v2                  99574ad1473c        About a minute ago   378 MB
phpdemo                             v1                  c62e0ad19807        17 minutes ago   378 MB
phpdemo                             v2                  99574ad1473c        About a minute ago   378 MB
manager1.example.com:5000/phpdemo   v1                  c62e0ad19807        18 minutes ago       378 MB
docker.io/php                       7.2-apache          2424d6c5e6b9        3 days ago           378 MB
docker.io/registry                  &amp;lt;none&amp;gt;              d0eed8dad114        12 days ago          25.8 MB
[root@manager1 docker-swarm-demo]#
[root@manager1 docker-swarm-demo]# docker push manager1.example.com:5000/phpdemo:v2
The push refers to a repository [manager1.example.com:5000/phpdemo]
b246f39fc10a: Pushed
29f6f251b4d2: Layer already exists
28255a6692d8: Layer already exists
d9b14cb17d8b: Layer already exists
725c91d33681: Layer already exists
005a87a63ac9: Layer already exists
66fd43b3ea3b: Layer already exists
20d941ba3638: Layer already exists
eb3e3e0ec224: Layer already exists
3843f6b0eab9: Layer already exists
63fc1837f67c: Layer already exists
c68025fbc229: Layer already exists
ec6f4f0a90dc: Layer already exists
0a07e81f5da3: Layer already exists
v2: digest: sha256:1542620ce99456e9cc6b8e55998f08707e68d0f7aa8c84a17457e20fd5623caa size: 3242
[root@manager1 docker-swarm-demo]#
&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 그럼 본격적으로 서비스를 운영하면서 변경된 Image 로 서비스 Rolling Update 를 하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 방법은 아래와 같습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker service update --update-parallelism 1 --image manager1.example.com:5000/phpdemo:v2 phpdemo
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;p&gt;
 --update-parallelism 옵션은 컨테이너 이미지가 한번에 얼마나 변경될지 결정합니다. 0일 경우, 한번에 변경합니다.
 &lt;strong&gt;
  &lt;br/&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker service update --update-parallelism 1 --image manager1.example.com:5000/phpdemo:v2 phpdemo
phpdemo
[root@manager1 docker-swarm-demo]# docker service ps phpdemo
ID            NAME           IMAGE                                 NODE                  DESIRED STATE  CURRENT STATE                ERROR                             PORTS
qo0dxm16hly5  phpdemo.1      manager1.example.com:5000/phpdemo:v2  manager2.example.com  Running        Running about a minute ago
m82bq5rgmk7z   \_ phpdemo.1  manager1.example.com:5000/phpdemo:v1  manager2.example.com  Shutdown       Shutdown about a minute ago
z7782l71gnum  phpdemo.2      manager1.example.com:5000/phpdemo:v2  manager3.example.com  Running        Running about a minute ago
msiyu6y2gjxn   \_ phpdemo.2  manager1.example.com:5000/phpdemo:v1  manager3.example.com  Shutdown       Shutdown about a minute ago
sxp3cs1vmn96  phpdemo.3      manager1.example.com:5000/phpdemo:v2  manager1.example.com  Running        Running about a minute ago
8x0pcftmzbzw   \_ phpdemo.3  manager1.example.com:5000/phpdemo:v1  manager1.example.com  Shutdown       Shutdown about a minute ago&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;strong&gt;
   # docker service ps
  &lt;/strong&gt;
 &lt;/em&gt;
 명령으로 보면 각 노드에 phpdemo:v2 로 이미지들이 교체가 된 것을 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 실제로 아래 그림을 보시면 이해에 도움이 됩니다.
&lt;/p&gt;
&lt;p&gt;
 하나씩 신규로 이미지를 교체하면서 서비스를 운영하면서 신규 이미지로 배포가 되는 것을 볼 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/7.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (상기 GIF 파일은 용량이 커서, 출력이 느릴수도 있습니다.)
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-서비스Rollback&quot;&gt;
 서비스 Rollback
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 서비스 Rolling Update 를 진행하였는데 문제가 발생되어 원복을 해야되는 상황이 발생 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Docker Swarm 은 Rollback 기능도 지원하고 있습니다.
&lt;/p&gt;
&lt;p&gt;
 Rollback 은 아래와 같이 수행 합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;strong&gt;
  &lt;em&gt;
   # docker service update --rollback phpdemo
  &lt;/em&gt;
 &lt;/strong&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker service update --rollback phpdemo
phpdemo

[root@manager1 docker-swarm-demo]# docker service ps phpdemo
ID            NAME           IMAGE                                 NODE                  DESIRED STATE  CURRENT STATE            ERROR  PORTS
u1w5rry6wvog  phpdemo.1      manager1.example.com:5000/phpdemo:v1  manager1.example.com  Running        Running 24 seconds ago
so0h6oyfdy65   \_ phpdemo.1  manager1.example.com:5000/phpdemo:v2  manager1.example.com  Shutdown       Shutdown 26 seconds ago
yzfysbktouw9  phpdemo.2      manager1.example.com:5000/phpdemo:v1  manager2.example.com  Running        Running 23 seconds ago
i3lqa52jspx4   \_ phpdemo.2  manager1.example.com:5000/phpdemo:v2  manager2.example.com  Shutdown       Shutdown 24 seconds ago
whoukoq2hwor   \_ phpdemo.2  manager1.example.com:5000/phpdemo:v1  manager2.example.com  Shutdown       Shutdown 2 minutes ago
z7782l71gnum   \_ phpdemo.2  manager1.example.com:5000/phpdemo:v2  manager3.example.com  Shutdown       Shutdown 3 minutes ago
msiyu6y2gjxn   \_ phpdemo.2  manager1.example.com:5000/phpdemo:v1  manager3.example.com  Shutdown       Shutdown 7 minutes ago
9ju17obshxlp  phpdemo.3      manager1.example.com:5000/phpdemo:v1  manager3.example.com  Running        Running 25 seconds ago
26s3p5fthc0f   \_ phpdemo.3  manager1.example.com:5000/phpdemo:v2  manager3.example.com  Shutdown       Shutdown 26 seconds ago
92g40nhfm15n   \_ phpdemo.3  manager1.example.com:5000/phpdemo:v1  manager3.example.com  Shutdown       Shutdown 3 minutes ago
sxp3cs1vmn96   \_ phpdemo.3  manager1.example.com:5000/phpdemo:v2  manager1.example.com  Shutdown       Shutdown 3 minutes ago
8x0pcftmzbzw   \_ phpdemo.3  manager1.example.com:5000/phpdemo:v1  manager1.example.com  Shutdown       Shutdown 7 minutes ago
[root@manager1 docker-swarm-demo]#&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;em&gt;
  &lt;strong&gt;
   # docker service ps
  &lt;/strong&gt;
 &lt;/em&gt;
 명령을 통해 확인해보면 Rollback 된 것을 자세히 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 실제로 서비스는 어떻게 Rollback 되는지는 아래 그림을 보면 됩니다.
&lt;/p&gt;
&lt;p&gt;
 컨테이너 하나씩 기존 이미지로 Rollback 을 진행 하는 것을 확인 할 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper confluence-embedded-manual-size&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/8.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (상기 GIF 파일은 용량이 커서, 출력이 느릴수도 있습니다.)
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h2 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-DockerHost장애발생으로인한복구시나리오&quot;&gt;
 Docker Host 장애 발생으로 인한 복구 시나리오
&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;
 서비스를 운영하다보면 어떠한 이유로 시스템에 장애가 발생되어 서비스가 중단되는 경우가 발생합니다.
&lt;/p&gt;
&lt;p&gt;
 Docker Swarm 을 이용하면 서비스 장애에 대해 감지하고 장애가 발생된 노드의 컨테이너를 다른 노드로 이관하여 장애 복구를 진행합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 인위적으로 manager2.example.com 의 시스템을 강제로 중지시켜 장애를 발생시키고 어떻게 Docker Swarm 에서 복구하는지 확인 해보겠습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;div class=&quot;code panel pdl conf-macro output-block&quot; data-hasbody=&quot;true&quot; data-macro-name=&quot;code&quot; style=&quot;border-width: 1px;&quot;&gt;
 &lt;div class=&quot;codeContent panelContent pdl&quot;&gt;
  &lt;pre class=&quot;syntaxhighlighter-pre&quot; data-syntaxhighlighter-params=&quot;brush: bash; gutter: false; theme: Emacs&quot; data-theme=&quot;Emacs&quot;&gt;[root@manager1 docker-swarm-demo]# docker node ls
ID                           HOSTNAME              STATUS  AVAILABILITY  MANAGER STATUS
lrt89xwkugty162qk8c2av5ek    manager2.example.com  Ready   Active        Leader
y8ul9r3jq0rgt9k3vbvrayeyg *  manager1.example.com  Ready   Active        Reachable
yqerq5ujds38t0izzlp03dbhd    manager3.example.com  Ready   Active        Reachable

[root@manager1 docker-swarm-demo]# docker service ps phpdemo
ID            NAME       IMAGE                                 NODE                  DESIRED STATE  CURRENT STATE               ERROR  PORTS
a50p5gs82hop  phpdemo.1  manager1.example.com:5000/phpdemo:v2  manager2.example.com  Running        Running about a minute ago
4vwicf8zt7j4  phpdemo.2  manager1.example.com:5000/phpdemo:v2  manager3.example.com  Running        Running 46 seconds ago
7ik901zrb0ob  phpdemo.3  manager1.example.com:5000/phpdemo:v2  manager1.example.com  Running        Running 51 seconds ago

// 노드 2번 시스템 인위적인 장애 발생

[root@manager1 docker-swarm-demo]# docker node ls
ID                           HOSTNAME              STATUS  AVAILABILITY  MANAGER STATUS
lrt89xwkugty162qk8c2av5ek    manager2.example.com  Down    Active        Unreachable
y8ul9r3jq0rgt9k3vbvrayeyg *  manager1.example.com  Ready   Active        Leader
yqerq5ujds38t0izzlp03dbhd    manager3.example.com  Ready   Active        Reachable
[root@manager1 docker-swarm-demo]#

[root@manager1 docker-swarm-demo]# docker service ps phpdemo
ID            NAME           IMAGE                                 NODE                  DESIRED STATE  CURRENT STATE               ERROR  PORTS
o32y0ozm5wpz  phpdemo.1      manager1.example.com:5000/phpdemo:v2  manager1.example.com  Running        Running about a minute ago
a50p5gs82hop   \_ phpdemo.1  manager1.example.com:5000/phpdemo:v2  manager2.example.com  Shutdown       Running 5 minutes ago
4vwicf8zt7j4  phpdemo.2      manager1.example.com:5000/phpdemo:v2  manager3.example.com  Running        Running about a minute ago
7ik901zrb0ob  phpdemo.3      manager1.example.com:5000/phpdemo:v2  manager1.example.com  Running        Running about a minute ago
[root@manager1 docker-swarm-demo]#&lt;/pre&gt;
 &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;
  &lt;img src=&quot;/assets/images/59736201/9.gif&quot;/&gt;
 &lt;/span&gt;
&lt;/p&gt;
&lt;p&gt;
 (상기 GIF 파일은 용량이 커서, 출력이 느릴수도 있습니다.)
&lt;/p&gt;
&lt;p&gt;
 위 그림을 보시면 장애 감지 및 장애 복구까지 소요된 시간이 약 40~50초 정도가 걸렸습니다.
&lt;/p&gt;
&lt;p&gt;
 manager2.example.com 시스템에 장애가 감지되고 해당 시스템에서 실행 중이던 컨테이너는 manager1.example.com 시스템에서 복구가 되는 것을 볼 수 있습니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-마치며&quot;&gt;
 마치며
&lt;/h1&gt;
&lt;hr/&gt;
&lt;p&gt;
 컨테이너 오케스트레이션 도구 중에 하나인 Docker Swarm 에 대해서 알아보는 시간이 였습니다.
&lt;/p&gt;
&lt;p&gt;
 구성이 간단하고 기존에 Docker 를 잘 사용하셨다면 쉽게 운영에 적용 할 수 있을 것 같습니다!!
&lt;/p&gt;
&lt;p&gt;
 또한 컨테이너 하나만으로는 부족한 느낌이 많이 없어진 것 같습니다. ^ㅡ^
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 언제나 쉽게 오픈소스를 사용할 수 있도록 노력하겠습니다.
&lt;/p&gt;
&lt;p&gt;
 감사합니다.
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;h1 id=&quot;DockerSwarm을이용한ContainerOrchestration환경만들기-참고자료&quot;&gt;
 참고 자료
&lt;/h1&gt;
&lt;hr/&gt;
&lt;ul&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://docs.docker.com/engine/swarm/&quot; rel=&quot;nofollow&quot;&gt;
   https://docs.docker.com/engine/swarm/
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://docs.docker.com/engine/reference/commandline/service_update/&quot; rel=&quot;nofollow&quot;&gt;
   https://docs.docker.com/engine/reference/commandline/service_update/
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://www.xenonstack.com/blog/top-trends-ci-cd-devops-tools/&quot; rel=&quot;nofollow&quot;&gt;
   https://www.xenonstack.com/blog/top-trends-ci-cd-devops-tools/
  &lt;/a&gt;
 &lt;/li&gt;
 &lt;li&gt;
  &lt;a class=&quot;external-link&quot; href=&quot;https://success.docker.com/article/networking&quot; rel=&quot;nofollow&quot;&gt;
   https://success.docker.com/article/networking
  &lt;/a&gt;
 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;
&lt;p&gt;
 &lt;br/&gt;
&lt;/p&gt;</description>
        <pubDate>Wed, 13 Feb 2019 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/2019/02/13/59736201/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/02/13/59736201/</guid>
        
        
      </item>
    
  </channel>
</rss>
